<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Adventure</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000;
  }
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 5;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
  }
  #startBtn:active { transform: translateY(1px); }

  .prompt, .dialog, .gameover, .hud {
    position: fixed; left: 50%; transform: translateX(-50%);
    color: #fff; text-align: center; font-weight: 600;
    text-shadow: 0 2px 0 rgba(0,0,0,.5);
    pointer-events: none;
  }
  .prompt { bottom: 8vh; background: rgba(0,0,0,.45); padding: 8px 12px; border-radius: 8px; }
  .dialog { bottom: 12vh; width: min(92vw, 700px); background: rgba(0,0,0,.6); padding: 14px 16px; border-radius: 10px; }
  .gameover { top: 20vh; font-size: clamp(22px, 4vw, 42px); }
  .hud { top: 10px; width: 100%; transform: none; left: 0; display:flex; justify-content: space-between; padding: 0 12px; }
  #gold {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    z-index: 6;
    font-size: 18px;
    pointer-events: none;
  }
  #restartBtn {
    margin-top: 16px; padding: 10px 16px; border: none; border-radius: 8px; cursor: pointer;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="startOverlay">
  <div id="title">Pixel Adventure</div>
  <button id="startBtn">Start Game</button>
</div>

<div class="hud" id="hud" style="display:none;">
  <div id="hearts"></div>
  <div id="gold">Gold: 0</div>
</div>

<div class="prompt" id="prompt" style="display:none;"></div>
<div class="dialog" id="dialog" style="display:none;"></div>
<div class="gameover" id="gameover" style="display:none;">
  <div>Game Over</div>
  <button id="restartBtn">Restart</button>
</div>

<script>
/* === Engine / canvas setup === */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;
function resize() {
  W = canvas.width  = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  ctx.imageSmoothingEnabled = false;
  buildStaticMap();
}
window.addEventListener("resize", resize);

/* === Input === */
const keys = new Set();
let lastPressedDir = 'down';
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "];
  if (moveKeys.includes(k)) e.preventDefault();
  keys.add(k);
});
window.addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

/* === Helpers === */
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

/* === Map Worlds === */
let mapBuffer, mapCtx;
let solidRects = [];
let world = "grass";
let questAccepted = false;
const door = {x:0,y:0,w:36,h:56,visible:false};

/* === Static map drawing functions === */
function buildStaticMap(){
  mapBuffer=document.createElement("canvas");
  mapBuffer.width=W;mapBuffer.height=H;
  mapCtx=mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled=false;
  solidRects=[];
  if(world==="grass") drawGrassWorld(mapCtx);
  else if(world==="dungeon") drawDungeon(mapCtx);
}
function drawGrassWorld(g){
  g.fillStyle="#53a653";g.fillRect(0,0,W,H);
  g.fillStyle="#458f45";
  for(let i=0;i<80;i++){
    const x=randi(0,W),y=randi(0,H),w=randi(30,60),h=randi(20,50);
    g.fillRect(x,y,w,h);solidRects.push({x,y,w,h});
  }
  g.fillStyle="#3d7a3d";
  for(let i=0;i<60;i++){
    const x=randi(0,W),y=randi(0,H),s=randi(25,60);
    g.beginPath();g.arc(x,y,s/2,0,Math.PI*2);g.fill();
    solidRects.push({x:x-s/2,y:y-s/2,w:s,h:s});
  }
}
function drawDungeon(g){
  g.fillStyle="#3a3a3a";g.fillRect(0,0,W,H);
  g.fillStyle="#333";for(let y=0;y<H;y+=60)g.fillRect(0,y,W,30);
  g.fillStyle="#2a2a2a";
  for(let i=0;i<100;i++){
    const x=randi(0,W),y=randi(0,H),s=randi(30,80);
    g.fillRect(x,y,s,s);solidRects.push({x,y,w:s,h:s});
  }
}
/* === Character sprite builders === */
const BASE_W = 16, BASE_H = 24, SCALE = 4, DRAW_W = BASE_W*SCALE, DRAW_H = BASE_H*SCALE;
function makeFrame(drawFn){const c=document.createElement("canvas");c.width=BASE_W;c.height=BASE_H;const g=c.getContext("2d");drawFn(g);return c;}
function p(g,x,y,color){g.fillStyle=color;g.fillRect(x,y,1,1);}

/* Palettes */
const skin="#f0c8a8",hair="#5a3a21",hairHL="#6b482b",eyes="#2a2a2a";
const outfitMain="#1f8a3c",outfitShadow="#166a2e",boots="#4b3928",belt="#2e2e2e";
const outfitMainSilvio="#2c57b4",outfitShadowSilvio="#223f82",hairSilvio="#4b3420";
const swordBlade="#cfd7df",swordEdge="#ffffff",swordHilt="#8b6a2b";

/* Zombie palette */
const zombieSkin="#9bb6a3",zombieEyes="#ffffff",zombieOutfit="#4a4a4a",zombiePants="#2a2a2a";

/* === Build Ana (player) frames === */
const anaFrames=[[],[],[],[]];
for(let dir=0;dir<4;dir++){for(let f=0;f<5;f++){anaFrames[dir][f]=makeFrame(g=>drawAna(g,dir,f));}}
function drawAna(g,dir,frameIndex){
  g.clearRect(0,0,BASE_W,BASE_H);
  const walkFrames=[{legL:-1,legR:1,armL:1,armR:-1},{legL:0,legR:0,armL:0,armR:0},{legL:1,legR:-1,armL:-1,armR:1},{legL:0,legR:0,armL:0,armR:0}];
  const isIdle=(frameIndex===0);
  const offs=isIdle?{armL:0,armR:0,legL:0,legR:0}:walkFrames[(frameIndex-1)%4];
  const headX=3,headTop=2,bodyTop=12,bodyX=3;
  for(let y=0;y<8;y++){for(let x=0;x<8;x++){p(g,headX+x,headTop+y,hair);}}
  for(let y=0;y<6;y++){for(let x=1;x<7;x++){p(g,headX+x,headTop+y,hairHL);}}
  for(let y=0;y<8;y++){for(let x=0;x<8;x++){p(g,headX+x,headTop+y,skin);}}
  p(g,headX+2,headTop+3,eyes);p(g,headX+5,headTop+3,eyes);
  for(let y=0;y<6;y++){for(let x=0;x<8;x++){p(g,bodyX+x,bodyTop+y,outfitMain);}}
  for(let y=0;y<6;y++){p(g,bodyX,bodyTop+y,outfitShadow);p(g,bodyX+7,bodyTop+y,outfitShadow);}
  for(let x=1;x<7;x++){p(g,bodyX+x,bodyTop+2,belt);}
  p(g,bodyX-1,bodyTop+1+offs.armL,skin);
  p(g,bodyX+8,bodyTop+1+offs.armR,skin);
  p(g,bodyX+1,bodyTop+7+offs.legL,boots);
  p(g,bodyX+5,bodyTop+7+offs.legR,boots);
}

/* === Build Silvio frames (blue outfit, brown hair) === */
const silvioFrames=[[],[],[],[]];
for(let dir=0;dir<4;dir++){for(let f=0;f<5;f++){silvioFrames[dir][f]=makeFrame(g=>drawSilvio(g,dir,f));}}
function drawSilvio(g,dir,frameIndex){
  g.clearRect(0,0,BASE_W,BASE_H);
  const headX=3,headTop=2,bodyTop=12,bodyX=3;
  for(let y=0;y<8;y++){for(let x=0;x<8;x++){p(g,headX+x,headTop+y,hairSilvio);}}
  for(let y=0;y<8;y++){for(let x=0;x<8;x++){p(g,headX+x,headTop+y,skin);}}
  p(g,headX+2,headTop+3,eyes);p(g,headX+5,headTop+3,eyes);
  for(let y=0;y<6;y++){for(let x=0;x<8;x++){p(g,bodyX+x,bodyTop+y,outfitMainSilvio);}}
  for(let y=0;y<6;y++){p(g,bodyX,bodyTop+y,outfitShadowSilvio);p(g,bodyX+7,bodyTop+y,outfitShadowSilvio);}
  for(let x=1;x<7;x++){p(g,bodyX+x,bodyTop+2,belt);}
  p(g,bodyX-1,bodyTop+2,skin);
  p(g,bodyX+8,bodyTop+2,skin);
  p(g,bodyX+1,bodyTop+7,boots);
  p(g,bodyX+5,bodyTop+7,boots);
}

/* === Build Zombie frames (unique undead look) === */
const zombieFrames=[[],[],[],[]];
for(let dir=0;dir<4;dir++){for(let f=0;f<5;f++){zombieFrames[dir][f]=makeFrame(g=>drawZombie(g,dir,f));}}
function drawZombie(g,dir,frameIndex){
  g.clearRect(0,0,BASE_W,BASE_H);
  const walkFrames=[{legL:-1,legR:1,armL:1,armR:-1},{legL:0,legR:0,armL:0,armR:0},{legL:1,legR:-1,armL:-1,armR:1},{legL:0,legR:0,armL:0,armR:0}];
  const isIdle=(frameIndex===0);
  const offs=isIdle?{armL:0,armR:0,legL:0,legR:0}:walkFrames[(frameIndex-1)%4];
  const headX=3,headTop=2,bodyTop=12,bodyX=3;
  for(let y=0;y<8;y++){for(let x=0;x<8;x++){p(g,headX+x,headTop+y,zombieSkin);}}
  p(g,headX+2,headTop+3,zombieEyes);p(g,headX+5,headTop+3,zombieEyes);
  for(let y=0;y<6;y++){for(let x=0;x<8;x++){p(g,bodyX+x,bodyTop+y,zombieOutfit);}}
  p(g,bodyX-1,bodyTop+1+offs.armL,zombieSkin);
  p(g,bodyX+8,bodyTop+1+offs.armR,zombieSkin);
  p(g,bodyX+1,bodyTop+7+offs.legL,zombiePants);
  p(g,bodyX+5,bodyTop+7+offs.legR,zombiePants);
}

/* === Entities === */
const player={x:0,y:0,dir:0,frame:0,frameTick:0,speed:3,hp:3,maxHp:3,gold:0};
const silvio={x:0,y:0,dir:1,frame:0};
function placeSilvio(){
  silvio.x=80; // middle-left
  silvio.y=Math.floor(H/2 - DRAW_H/2);
}
let zombies=[],coins=[];

/* === Sword swing animation (Terraria style) === */
let swingTimer=0,swingDuration=12;
function drawSword(ctx,px,py,dir,t){
  ctx.save();ctx.translate(px,py);
  let startAngle,endAngle;
  if(dir===0){startAngle=Math.PI*0.2;endAngle=Math.PI*0.8;}
  if(dir===1){startAngle=Math.PI*1.1;endAngle=Math.PI*1.9;}
  if(dir===2){startAngle=Math.PI*1.9;endAngle=Math.PI*0.1;}
  if(dir===3){startAngle=-Math.PI*0.9;endAngle=-Math.PI*0.1;}
  const angle=startAngle+(endAngle-startAngle)*t;
  ctx.rotate(angle);
  ctx.fillStyle=swordBlade;ctx.fillRect(0,-2,40,4);
  ctx.fillStyle=swordEdge;ctx.fillRect(36,-3,4,6);
  ctx.fillStyle=swordHilt;ctx.fillRect(-6,-3,6,6);
  ctx.restore();
}
/* === Collisions & movement === */
function rectsOverlap(a,b){return !(a.x+a.w<=b.x||a.x>=b.x+b.w||a.y+a.h<=b.y||a.y>=b.y+b.h);}
function circleHit(ax,ay,bx,by,r){const dx=ax-bx,dy=ay-by;return (dx*dx+dy*dy)<=r*r;}

function tryMove(dx,dy){
  const feet={x:player.x+DRAW_W*0.25,y:player.y+DRAW_H*0.65,w:DRAW_W*0.5,h:DRAW_H*0.3};
  const nextFeet={x:feet.x+dx,y:feet.y+dy,w:feet.w,h:feet.h};
  // keep inside screen
  if(nextFeet.x<0||nextFeet.y<0||nextFeet.x+nextFeet.w>W||nextFeet.y+nextFeet.h>H) return;
  // collide with solids
  for(const s of solidRects){
    if(rectsOverlap(nextFeet,s)){
      // try slide on X
      const feetX={...feet,x:feet.x+dx};
      if(!rectsOverlap(feetX,s)){player.x+=dx;return;}
      // try slide on Y
      const feetY={...feet,y:feet.y+dy};
      if(!rectsOverlap(feetY,s)){player.y+=dy;return;}
      return;
    }
  }
  player.x+=dx; player.y+=dy;
}

/* === UI elements === */
const startOverlay=document.getElementById('startOverlay');
const startBtn=document.getElementById('startBtn');
const promptEl=document.getElementById('prompt');
const dialogEl=document.getElementById('dialog');
const hudEl=document.getElementById('hud');
const heartsEl=document.getElementById('hearts');
const goldEl=document.getElementById('gold');
const gameoverEl=document.getElementById('gameover');
const restartBtn=document.getElementById('restartBtn');

function showPrompt(t){promptEl.textContent=t;promptEl.style.display='block';}
function hidePrompt(){promptEl.style.display='none';}
function showDialog(t){dialogEl.textContent=t;dialogEl.style.display='block';}
function hideDialog(){dialogEl.style.display='none';}

/* === HUD === */
function setHUD(){
  const full="❤",empty="♡";
  heartsEl.textContent=full.repeat(player.hp)+empty.repeat(Math.max(0,player.maxHp-player.hp));
  goldEl.textContent="Gold: "+player.gold;
}

/* === Door drawing (to dungeon) === */
function drawDoor(g,x,y,w,h){
  g.fillStyle="#6b4a2b";g.fillRect(x,y,w,h);
  g.fillStyle="#8a663c";g.fillRect(x+4,y+4,w-8,h-8);
  g.fillStyle="#2a241f";g.fillRect(x+w/2-2,y+h-14,4,8);
}

/* === Dialog / quest acceptance === */
let dialogActive=false, dialogStep=0;
function startDialog(){
  dialogActive=true; dialogStep=0;
  showDialog('Silvio: "Will you accept my quest my love?"  (Press Space)');
}
function updateDialog(){
  if(!dialogActive) return;
  if(keys.has(' ')||keys.has('space')){
    dialogActive=false; hideDialog();
    questAccepted=true;
    // do NOT rebuild the map here (prevents grass from regenerating)
    door.visible=true;
    door.x=W-120; door.y=80;
  }
}

/* === Hand anchor for sword & swing control === */
function getHandAnchor(dir){
  const baseX=player.x+DRAW_W/2;
  const baseY=player.y+DRAW_H*0.72;
  if(dir===0) return {x:baseX,y:baseY};            // down
  if(dir===1) return {x:baseX-10,y:baseY-6};       // left
  if(dir===2) return {x:baseX+10,y:baseY-6};       // right
  return {x:baseX,y:baseY-18};                     // up
}
function swingProgress(){return Math.min(1, swingTimer/ swingDuration);}

/* === Zombies / coins === */
function spawnZombie(){
  const z={x:randi(40,W-40),y:randi(40,H-40),w:DRAW_W,h:DRAW_H,dir:0,frame:0,animTime:0,speed:1.4,alive:true,hp:2};
  zombies.push(z);
}
function updateZombies(){
  if(world==="dungeon" && zombies.length<7 && Math.random()<0.02) spawnZombie();
  for(const z of zombies){
    if(!z.alive) continue;
    const dx=(player.x - z.x), dy=(player.y - z.y);
    const d=Math.hypot(dx,dy)||1;
    const vx=dx/d, vy=dy/d;
    z.x += vx * z.speed * 2.5; // shuffle
    z.y += vy * z.speed * 2.5;

    // face direction
    if(Math.abs(vx)>Math.abs(vy)) z.dir=(vx<0)?1:2; else z.dir=(vy<0)?3:0;

    z.animTime += 0.18;
    z.frame = 1 + (Math.floor(z.animTime)%4);

    // contact damage (simple feet boxes)
    const feetP={x:player.x+DRAW_W*0.25,y:player.y+DRAW_H*0.65,w:DRAW_W*0.5,h:DRAW_H*0.3};
    const feetZ={x:z.x+DRAW_W*0.25,y:z.y+DRAW_H*0.65,w:DRAW_W*0.5,h:DRAW_H*0.3};
    if(rectsOverlap(feetP,feetZ) && dmgCooldown<=0){
      player.hp=Math.max(0,player.hp-1);
      dmgCooldown=45; // frames of i-frames
      if(player.hp<=0){ gameOver(); }
    }
  }
}
function dropCoin(x,y){coins.push({x,y,r:7});}
function updateCoins(){
  for(let i=coins.length-1;i>=0;i--){
    const c=coins[i];
    const px=player.x+DRAW_W/2, py=player.y+DRAW_H*0.8;
    if(circleHit(px,py,c.x,c.y,22)){ player.gold++; coins.splice(i,1); }
  }
}

/* === Sword hit detection along the swing arc === */
function hitZombiesWithSword(){
  if(swingTimer===0) return;
  const t=Math.min(1,swingTimer/swingDuration);
  const hand=getHandAnchor(player.dir);

  // Same angle as drawSword()
  let startAngle,endAngle;
  if(player.dir===0){startAngle=Math.PI*0.2;endAngle=Math.PI*0.8;}
  if(player.dir===1){startAngle=Math.PI*1.1;endAngle=Math.PI*1.9;}
  if(player.dir===2){startAngle=Math.PI*1.9;endAngle=Math.PI*0.1;}
  if(player.dir===3){startAngle=-Math.PI*0.9;endAngle=-Math.PI*0.1;}
  const angle=startAngle+(endAngle-startAngle)*t;

  const reach=36;
  const cx=hand.x + Math.cos(angle)*reach;
  const cy=hand.y + Math.sin(angle)*reach;

  for(const z of zombies){
    if(!z.alive) continue;
    const zx=z.x + DRAW_W/2, zy=z.y + DRAW_H*0.75;
    if(circleHit(cx,cy,zx,zy,28)){
      z.hp -= 1;
      if(z.hp<=0){ z.alive=false; dropCoin(zx,zy-10); }
    }
  }
}

/* === Input & player update === */
let dmgCooldown=0;
function updatePlayer(){
  // movement
  let vx=0,vy=0;
  if(keys.has("arrowleft")||keys.has("a")){vx-=1; lastPressedDir='left';}
  if(keys.has("arrowright")||keys.has("d")){vx+=1; lastPressedDir='right';}
  if(keys.has("arrowup")||keys.has("w")){vy-=1; lastPressedDir='up';}
  if(keys.has("arrowdown")||keys.has("s")){vy+=1; lastPressedDir='down';}
  if(vx!==0||vy!==0){
    const len=Math.hypot(vx,vy)||1; vx/=len; vy/=len;
    if(Math.abs(vx)>Math.abs(vy)) player.dir=(vx<0)?1:2;
    else if(Math.abs(vy)>0) player.dir=(vy<0)?3:0;
    tryMove(vx*player.speed*2.6, vy*player.speed*2.6);
    player.frameTick++; player.frame=1+((player.frameTick>>2)%4);
  }else{ player.frame=0; }

  // start swing
  if((keys.has(' ')||keys.has('space')) && swingTimer===0){ swingTimer=1; }

  // progress swing
  if(swingTimer>0){
    swingTimer++;
    hitZombiesWithSword();
    if(swingTimer> swingDuration){ swingTimer=0; }
  }

  if(dmgCooldown>0) dmgCooldown--;
}

/* === Door interaction & world switch === */
function handleDoor(){
  if(world!=="grass" || !questAccepted || !door.visible) return;
  drawDoor(ctx,door.x,door.y,door.w,door.h); // render on top of map
  // interact
  const feet={x:player.x+DRAW_W*0.25,y:player.y+DRAW_H*0.65,w:DRAW_W*0.5,h:DRAW_H*0.3};
  const doorBox={x:door.x,y:door.y,w:door.w,h:door.h};
  if(rectsOverlap(feet,doorBox)){
    showPrompt("Press E to enter");
    if(keys.has('e')){
      world="dungeon";
      zombies.length=0; coins.length=0;
      buildStaticMap();
      // place player near bottom-left on entry
      player.x=80; player.y=H - DRAW_H - 80;
      hidePrompt();
    }
  }else hidePrompt();
}

/* === Rendering === */
function render(){
  // map
  ctx.drawImage(mapBuffer,0,0);

  // door (grass only)
  if(world==="grass" && questAccepted && door.visible){
    drawDoor(ctx,door.x,door.y,door.w,door.h);
  }

  // Silvio (grass only)
  if(world==="grass"){
    const imgS=silvioFrames[1][0];
    ctx.drawImage(imgS,0,0,BASE_W,BASE_H,Math.round(silvio.x),Math.round(silvio.y),DRAW_W,DRAW_H);
    ctx.fillStyle="#fff";ctx.font="16px monospace";ctx.textAlign="center";
    ctx.fillText("Silvio",Math.round(silvio.x+DRAW_W/2),Math.round(silvio.y-10));
    if(!questAccepted){
      // floating '?'
      ctx.fillText("?",Math.round(silvio.x+DRAW_W/2),Math.round(silvio.y-28));
    }
  }

  // dungeon mobs / coins
  if(world==="dungeon"){
    for(const z of zombies){ if(!z.alive) continue;
      const img=zombieFrames[z.dir][z.frame];
      ctx.drawImage(img,0,0,BASE_W,BASE_H,Math.round(z.x),Math.round(z.y),DRAW_W,DRAW_H);
    }
    for(const c of coins){
      ctx.fillStyle="#ffd43b";ctx.beginPath();ctx.arc(c.x,c.y,6,0,Math.PI*2);ctx.fill();
      ctx.fillStyle="#fff3a0";ctx.fillRect(c.x-2,c.y-3,4,2);
    }
  }

  // player
  const img=anaFrames[player.dir][player.frame];
  ctx.save();
  if(dmgCooldown>0 && (dmgCooldown%6<3)) ctx.globalAlpha=0.6;
  ctx.drawImage(img,0,0,BASE_W,BASE_H,Math.round(player.x),Math.round(player.y),DRAW_W,DRAW_H);
  ctx.restore();

  // sword (only while swinging)
  if(swingTimer>0){
    const t=swingProgress();
    const hand=getHandAnchor(player.dir);
    drawSword(ctx,hand.x,hand.y,player.dir,t);
    // simple trail
    ctx.strokeStyle="rgba(255,255,255,0.35)";
    ctx.lineWidth=2;
    let startAngle,endAngle;
    if(player.dir===0){startAngle=Math.PI*0.2;endAngle=Math.PI*0.8;}
    if(player.dir===1){startAngle=Math.PI*1.1;endAngle=Math.PI*1.9;}
    if(player.dir===2){startAngle=Math.PI*1.9;endAngle=Math.PI*0.1;}
    if(player.dir===3){startAngle=-Math.PI*0.9;endAngle=-Math.PI*0.1;}
    const ang=startAngle+(endAngle-startAngle)*t;
    ctx.beginPath();ctx.arc(hand.x,hand.y,36,startAngle,ang,false);ctx.stroke();
  }

  // player label
  ctx.fillStyle="#fff";ctx.font="18px monospace";ctx.textAlign="center";
  ctx.fillText("Ana",Math.round(player.x+DRAW_W/2),Math.round(player.y-10));
}

/* === Game Over === */
function gameOver(){
  running=false;
  document.getElementById('gameover').style.display='block';
}

/* === Main loop === */
let running=false, lastTs=0;
function loop(ts){
  if(!running) return;
  const dt=(ts-lastTs)/1000||0; lastTs=ts;

  if(dialogActive){ updateDialog(); }
  else{
    updatePlayer();
    if(world==="dungeon"){ updateZombies(); updateCoins(); }
    if(world==="grass"){
      // talk prompt near Silvio
      const px=player.x+DRAW_W/2, py=player.y+DRAW_H*0.8;
      const sx=silvio.x+DRAW_W/2, sy=silvio.y+DRAW_H*0.8;
      const near=Math.hypot(px-sx,py-sy)<120;
      if(!questAccepted && near){
        showPrompt("Press E to accept quest");
        if(keys.has('e')){ hidePrompt(); startDialog(); }
      }else if(!questAccepted){ hidePrompt(); }
      handleDoor();
    }
  }

  setHUD();
  render();
  requestAnimationFrame(loop);
}

/* === Start / Restart === */
startBtn.addEventListener('click',()=>{
  startOverlay.style.display='none';
  running=true; lastTs=performance.now();
  requestAnimationFrame(loop);
});
restartBtn.addEventListener('click',()=>{
  player.x=(W-DRAW_W)/2; player.y=(H-DRAW_H)/2;
  player.hp=player.maxHp; player.gold=0; dmgCooldown=0;
  world="grass"; questAccepted=true; door.visible=true;
  zombies.length=0; coins.length=0;
  buildStaticMap();
  document.getElementById('gameover').style.display='none';
});

/* === Initial placement === */
resize();
placeSilvio();
player.x=(W-DRAW_W)/2;
player.y=(H-DRAW_H)/2;
buildStaticMap();
setHUD();
/* === Accessibility niceties (optional) === */
window.addEventListener('blur',()=>{ /* keep running but you could pause if desired */ });
window.addEventListener('contextmenu',(e)=>{ e.preventDefault(); });

/* === Mobile touch (simple d-pad & attack) === */
let touchMove = null;
let attackTouch = false;

function createTouchUI(){
  const pad = document.createElement('div');
  pad.style.position='fixed'; pad.style.left='16px'; pad.style.bottom='16px';
  pad.style.width='120px'; pad.style.height='120px';
  pad.style.borderRadius='12px'; pad.style.background='rgba(255,255,255,0.07)';
  pad.style.backdropFilter='blur(2px)'; pad.style.zIndex='8';
  pad.style.touchAction='none';
  document.body.appendChild(pad);

  const attack = document.createElement('div');
  attack.style.position='fixed'; attack.style.right='16px'; attack.style.bottom='16px';
  attack.style.width='88px'; attack.style.height='88px';
  attack.style.borderRadius='50%'; attack.style.background='rgba(255,255,255,0.07)';
  attack.style.backdropFilter='blur(2px)'; attack.style.zIndex='8';
  attack.style.touchAction='none';
  document.body.appendChild(attack);

  function setMoveFromPoint(x,y){
    const rect = pad.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = x - cx;
    const dy = y - cy;
    const len = Math.hypot(dx,dy) || 1;
    const nx = dx/len, ny = dy/len;
    touchMove = {nx, ny};
    // map to keys
    if(Math.abs(nx)>Math.abs(ny)){
      if(nx<0){ keys.add('a'); keys.delete('d'); } else { keys.add('d'); keys.delete('a'); }
      keys.delete('w'); keys.delete('s');
    }else{
      if(ny<0){ keys.add('w'); keys.delete('s'); } else { keys.add('s'); keys.delete('w'); }
      keys.delete('a'); keys.delete('d');
    }
  }
  function clearMove(){
    touchMove = null;
    keys.delete('w');keys.delete('a');keys.delete('s');keys.delete('d');
  }

  pad.addEventListener('touchstart',e=>{ if(e.touches[0]) setMoveFromPoint(e.touches[0].clientX,e.touches[0].clientY); });
  pad.addEventListener('touchmove',e=>{ if(e.touches[0]) setMoveFromPoint(e.touches[0].clientX,e.touches[0].clientY); });
  pad.addEventListener('touchend',()=>{ clearMove(); });
  pad.addEventListener('touchcancel',()=>{ clearMove(); });

  function pressAttack(){ keys.add(' '); setTimeout(()=>keys.delete(' '), 40); }
  attack.addEventListener('touchstart',()=>{ attackTouch=true; pressAttack(); });
  attack.addEventListener('touchend',()=>{ attackTouch=false; });
  attack.addEventListener('touchcancel',()=>{ attackTouch=false; });
}

if(/Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent)){ createTouchUI(); }

</script>
</body>
</html>
