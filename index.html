<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Adventure — Snow Quest</title>
<style>
  /* ===== Base layout ===== */
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000; /* covered by map buffer */
  }

  /* ===== Overlay (start) ===== */
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 5;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
  }
  #startBtn:active { transform: translateY(1px); }

  /* ===== HUD ===== */
  .hud {
    position: fixed;
    left: 50%;
    top: 10px;
    transform: translateX(-50%);
    z-index: 6;
    display: flex;
    align-items: center;
    gap: 12px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 1px 0 #000, 0 0 6px #000;
    user-select: none;
    pointer-events: none;
  }
  .hud .hearts {
    display: inline-flex; gap: 6px;
  }
  .hud .heart {
    width: 18px; height: 18px; border-radius: 3px;
    background: #e53935; outline: 1px solid #000;
    box-shadow: 0 0 0 2px rgba(0,0,0,.25) inset;
  }
  .hud .heart.off { background: #3a3a3a; }
  .hud .gold {
    padding: 4px 8px;
    background: rgba(0,0,0,.35);
    border-radius: 6px;
    outline: 1px solid rgba(255,255,255,.15);
  }

  /* ===== Prompt / Dialog ===== */
  #prompt, #dialog {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    color: #fff;
    text-shadow: 0 1px 0 #000, 0 0 6px #000;
    pointer-events: none;
    z-index: 6;
  }
  #prompt {
    top: 64px;
    font-size: clamp(12px, 2vw, 18px);
    background: rgba(0,0,0,.35);
    padding: 8px 12px;
    border-radius: 8px;
    outline: 1px solid rgba(255,255,255,.15);
    display: none;
  }
  #dialog {
    bottom: 8vh;
    width: min(900px, 92vw);
    background: rgba(0,0,0,.6);
    padding: 14px 16px;
    border-radius: 12px;
    outline: 1px solid rgba(255,255,255,.2);
    display: none;
  }
  #dialog .name {
    display: block;
    font-weight: 800;
    letter-spacing: .5px;
    margin-bottom: 6px;
  }
  #dialog .line {
    display: block;
    line-height: 1.5;
    font-size: clamp(14px, 2.2vw, 18px);
  }

  /* ===== Door indicator (top-right) ===== */
  .cornerNote {
    position: fixed;
    right: 12px;
    top: 12px;
    z-index: 6;
    color: #fff;
    opacity: .8;
    font-size: 12px;
    text-shadow: 0 1px 0 #000, 0 0 6px #000;
    user-select: none;
    pointer-events: none;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="startOverlay">
  <div id="title">Pixel Adventure — Snow Quest</div>
  <button id="startBtn">Start Game</button>
</div>

<!-- HUD (top-center, stays centered) -->
<div class="hud" id="hud">
  <div class="hearts" id="hearts"></div>
  <div class="gold" id="goldHUD">Gold: <span id="goldCount">0</span></div>
</div>

<!-- Interaction prompt -->
<div id="prompt">Press E to accept quest</div>

<!-- Blocking dialog -->
<div id="dialog">
  <span class="name" id="dlgName"></span>
  <span class="line" id="dlgLine"></span>
</div>

<!-- Tiny helper for door placement info -->
<div class="cornerNote">Door is fixed in the top-right corner →</div>

<script>
/* ==========================================================
   Canvas + Context
   ========================================================== */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;

/* ==========================================================
   Deterministic RNG so the map NEVER shuffles after quest
   ========================================================== */
function makeRNG(seed = 1337) {
  // mulberry32
  let t = seed >>> 0;
  return function() {
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ t >>> 15, 1 | t);
    r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
    return ((r ^ r >>> 14) >>> 0) / 4294967296;
  };
}
function randi(rng, min, max) { return Math.floor(rng() * (max - min + 1)) + min; }

/* ==========================================================
   Resize (build map once, never rebuild on quest)
   ========================================================== */
let mapBuilt = false;
function resize() {
  W = canvas.width  = Math.max(320, Math.floor(window.innerWidth));
  H = canvas.height = Math.max(240, Math.floor(window.innerHeight));
  ctx.imageSmoothingEnabled = false;
  if (!mapBuilt) {
    buildStaticSnowMap(); // only once!
    placeFixedWorldThings(); // door + silvio fixed placement
    mapBuilt = true;
  } else {
    // When resizing, we keep the precomputed layers; just redraw.
    // (Rebuilding keeps the same PRNG data; positions don't change.)
    rebuildMapBufferForSize(); // redraw cached features to new buffer without re-randomizing
  }
}
window.addEventListener("resize", resize);

/* ==========================================================
   Input
   ========================================================== */
const keys = new Set();
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "];
  if (moveKeys.includes(k)) e.preventDefault();
  keys.add(k);

  // Interact with Silvio (quest)
  if (k === "e") tryStartQuest();

  // Continue dialog (space)
  if (k === " " || k === "spacebar" || k === "space") {
    if (dialogActive) advanceDialog();
    else playerAttack();
  }
});
window.addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

/* ==========================================================
   World Layers (Snow map with deterministic content)
   ========================================================== */
let mapBuffer, mapCtx;

/* precomputed decor (so it never moves): */
let snowPatches = [];   // {x,y,size}
let flowers = [];       // {x,y,type}
let trees = [];         // {x,y,trunk:{x,y,w,h}}
let rocks = [];         // {x,y,sz}
let snowDrifts = [];    // {x,y,w,h,alpha}

/* fixed world items (also deterministic) */
const door = { x: 0, y: 0, w: 34, h: 54 };  // position set after map size known
const silvio = { x: 0, y: 0, w: 22*4, h: 34*4, dir: 0 }; // set after size known (center-ish)

/* Build once with a fixed seed so the layout is stable */
const MAP_SEED = 987654321;
let rng = makeRNG(MAP_SEED);

function buildStaticSnowMap() {
  // Clear any earlier arrays (in case we resize and redraw from stored seeds)
  snowPatches.length = 0; flowers.length = 0; trees.length = 0; rocks.length = 0; snowDrifts.length = 0;

  // Use a fresh RNG from the same seed so content is the same EVERY time we call this.
  rng = makeRNG(MAP_SEED);

  // Precompute decor positions relative to [0..W] & [0..H]
  // Snow field base patches (very subtle blue/white)
  const patchCount = Math.floor((W*H)/14000);
  for (let i = 0; i < patchCount; i++) {
    snowPatches.push({ x: randi(rng, 0, W), y: randi(rng, 0, H), size: randi(rng, 20, 90) });
  }

  // Frozen flowers (muted tones)
  const flowerCount = Math.floor((W*H)/90000);
  for (let i = 0; i < flowerCount; i++) {
    flowers.push({ x: randi(rng, 8, W-8), y: randi(rng, 8, H-8), type: randi(rng, 0, 2) });
  }

  // Evergreens (tree collision trunks)
  const treeCount = Math.floor((W*H)/52000);
  for (let i = 0; i < treeCount; i++) {
    const x = randi(rng, 60, W-60);
    const y = randi(rng, 60, H-60);
    const trunkW = 14, trunkH = 28, tx = x - trunkW/2, ty = y + 10;
    trees.push({ x, y, trunk: { x: tx, y: ty, w: trunkW, h: trunkH } });
  }

  // Scattered icy rocks
  const rockCount = Math.floor((W*H)/110000);
  for (let i = 0; i < rockCount; i++) {
    rocks.push({ x: randi(rng, 20, W-20), y: randi(rng, 20, H-20), sz: randi(rng, 8, 16) });
  }

  // Snow drifts / foggy wisps
  const driftCount = Math.floor((W*H)/170000);
  for (let i = 0; i < driftCount; i++) {
    snowDrifts.push({
      x: randi(rng, 0, W), y: randi(rng, 0, H),
      w: randi(rng, 120, 240), h: randi(rng, 60, 120),
      alpha: 0.15 + rng()*0.15
    });
  }

  // Build the initial buffer
  rebuildMapBufferForSize();
}

function rebuildMapBufferForSize() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  // Base snow
  mapCtx.fillStyle = "#cfe6ff";
  mapCtx.fillRect(0,0,W,H);

  // Subtle noise tiling
  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = (Math.sin(x*12.9898 + y*78.233) * 43758.5453) % 1;
      if (v < 0.16) {
        mapCtx.fillStyle = "#d8eeff";
        mapCtx.fillRect(x, y, cell, cell);
      } else if (v < 0.26) {
        mapCtx.fillStyle = "#bfe0ff";
        mapCtx.fillRect(x, y, cell, cell);
      }
    }
  }

  // Snow patches
  for (const p of snowPatches) {
    const g = mapCtx.createRadialGradient(p.x, p.y, 1, p.x, p.y, p.size);
    g.addColorStop(0, "rgba(255,255,255,0.9)");
    g.addColorStop(1, "rgba(255,255,255,0.05)");
    mapCtx.fillStyle = g;
    mapCtx.beginPath();
    mapCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    mapCtx.fill();
  }

  // Frozen flowers
  for (const f of flowers) {
    if (f.type === 0) mapCtx.fillStyle = "#f7d1ff";
    if (f.type === 1) mapCtx.fillStyle = "#fff6bf";
    if (f.type === 2) mapCtx.fillStyle = "#bde7ff";
    mapCtx.fillRect(f.x, f.y, 3, 3);
    mapCtx.fillRect(f.x+2, f.y+1, 2, 2);
    mapCtx.fillRect(f.x-1, f.y+1, 2, 2);
    mapCtx.fillStyle = "#2f7b7b";
    mapCtx.fillRect(f.x+1, f.y+3, 1, 3);
  }

  // Trees (foliage and trunks)
  for (const t of trees) drawEvergreen(mapCtx, t.x, t.y, t.trunk);

  // Rocks (icy)
  for (const r of rocks) {
    mapCtx.fillStyle = "#e7f2ff";
    mapCtx.beginPath();
    mapCtx.arc(r.x, r.y, r.sz/2, 0, Math.PI*2);
    mapCtx.fill();
    mapCtx.fillStyle = "#a4c2de";
    mapCtx.fillRect(r.x-1, r.y-1, 2, 2);
  }

  // Snow drifts (soft fog)
  for (const d of snowDrifts) {
    mapCtx.fillStyle = `rgba(255,255,255,${d.alpha})`;
    mapCtx.beginPath();
    mapCtx.ellipse(d.x, d.y, d.w/2, d.h/2, 0, 0, Math.PI*2);
    mapCtx.fill();
  }

  // Door (fixed top-right corner, drawn on map layer so it's "world" art)
  drawDoorOnMap();
}

function drawEvergreen(g, x, y, trunk) {
  // Cone foliage (dark -> light)
  for (let i = 0; i < 5; i++) {
    g.fillStyle = (i % 2 ? "#367e67" : "#2a6a57");
    const w = 56 - i*8, h = 16;
    g.beginPath();
    g.moveTo(x - w/2, y - 8 + i*h*0.5);
    g.lineTo(x + w/2, y - 8 + i*h*0.5);
    g.lineTo(x, y - 28 + i*h);
    g.closePath();
    g.fill();
  }
  // Snow caps
  g.fillStyle = "#e9f7ff";
  g.beginPath();
  g.arc(x, y-26, 12, 0, Math.PI*2);
  g.fill();

  // Trunk (solid for collision)
  g.fillStyle = "#7b5a3a";
  g.fillRect(trunk.x, trunk.y, trunk.w, trunk.h);
  g.fillStyle = "#8e6b48";
  g.fillRect(trunk.x+4, trunk.y+3, 4, trunk.h-6);
}

function drawDoorOnMap() {
  // Door sprite (simple wood door topped with snow)
  const m = 16; // margin from edges
  // Always stick to top-right corner
  door.x = W - m - door.w;
  door.y = m + 12;

  const g = mapCtx;
  // snow cap
  g.fillStyle = "#ffffff";
  g.fillRect(door.x-3, door.y-8, door.w+6, 10);
  // body
  g.fillStyle = "#8b5a2b";
  g.fillRect(door.x, door.y, door.w, door.h);
  g.fillStyle = "#a06c38";
  g.fillRect(door.x+6, door.y+4, door.w-12, door.h-8);
  // handle
  g.fillStyle = "#e0d090";
  g.fillRect(door.x+door.w-10, door.y+door.h/2, 4, 4);
}

/* Place Silvio AFTER size known (center-ish, fixed) */
function placeFixedWorldThings() {
  // Place Silvio roughly in the middle of map (not affected by quest)
  silvio.x = Math.round(W/2 - 36);
  silvio.y = Math.round(H/2 - 72);
}

/* ==========================================================
   Collision Solids (tree trunks only)
   ========================================================== */
function getSolids() {
  // Use tree trunks for collision; door area isn't solid (teleporter)
  return trees.map(t => ({ x: t.trunk.x, y: t.trunk.y, w: t.trunk.w, h: t.trunk.h }));
}

/* ==========================================================
   Character Sprite System (Ana & Silvio)
   ========================================================== */
const BASE_W = 16, BASE_H = 24;
const SCALE = 4;
const DRAW_W = BASE_W * SCALE;   // Ana size
const DRAW_H = BASE_H * SCALE;
const DRAW_W_SILV = Math.round(BASE_W * SCALE * 1.15); // Silvio a bit wider/taller
const DRAW_H_SILV = Math.round(BASE_H * SCALE * 1.15);

function makeFrame(drawFn) {
  const c = document.createElement("canvas");
  c.width = BASE_W; c.height = BASE_H;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;
  drawFn(g);
  return c;
}
function px(g, x, y, color) { g.fillStyle = color; g.fillRect(x, y, 1, 1); }

/* ====== Palette ====== */
const skin = "#f0c8a8";
const hairAna = "#5a3a21";
const hairSilvio = "#6b4022";
const hairHL = "#6b482b";
const eyes = "#2a2a2a";
const outfitAna = "#1f8a3c";
const outfitAnaShadow = "#166a2e";
const outfitSilv = "#274c9c";
const outfitSilvShadow = "#1e3c79";
const boots = "#4b3928";
const belt = "#2e2e2e";

/* Generic character builder */
function drawCharacter(g, dir, frameIndex, palette) {
  g.clearRect(0,0,BASE_W,BASE_H);

  const walkFrames = [
    {legL: -2, legR: 2, armL: 2, armR: -2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 2,  legR: -2, armL: -2, armR: 2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0},  // down
    {headY:-1, bodyY:0, arm:-1},// left
    {headY:-1, bodyY:0, arm:1}, // right
    {headY:0, bodyY:-1, arm:0}, // up
  ];

  const isIdle = (frameIndex === 0);
  let headY=0, bodyY=0, armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;
  if (isIdle) {
    const ip = idlePose[dir];
    headY = ip.headY; bodyY = ip.bodyY;
    armSwingL = ip.arm; armSwingR = -ip.arm;
  } else {
    const w = walkFrames[(frameIndex-1) % 4];
    armSwingL = w.armL; armSwingR = w.armR;
    legSwingL = w.legL; legSwingR = w.legR;
  }

  const headX = 3, headTop = 2 + headY;
  const bodyTop = 12 + bodyY;
  const bodyX = 3;

  function hairBack(col) {
    for (let x=2; x<=13; x++) px(g,x,headTop, col);
    for (let x=1; x<=14; x++) px(g,x,headTop+1, col);
    for (let x=1; x<=14; x++) px(g,x,headTop+2, col);
    for (let x=1; x<=14; x++) px(g,x,headTop+3, col);
    for (let x=2; x<=13; x++) px(g,x,headTop+4, col);
    px(g,2, headTop+5, col); px(g,13, headTop+5, col);
  }
  function headFront(hairMain) {
    for (let y=0; y<8; y++)
      for (let x=0; x<8; x++)
        px(g, headX+x, headTop+1+y, skin);
    for (let x=headX+1; x<=headX+6; x++) px(g, x, headTop+9, skin);
    if (dir === 0) { // down
      px(g, headX, headTop+1, hairHL);
      px(g, headX+7, headTop+1, hairHL);
      px(g, headX+2, headTop+1, hairMain);
      px(g, headX+5, headTop+1, hairMain);
    } else if (dir === 1) {
      for (let y=0; y<6; y++) px(g, headX, headTop+2+y, hairHL);
      px(g, headX+1, headTop+2, hairHL);
    } else if (dir === 2) {
      for (let y=0; y<6; y++) px(g, headX+7, headTop+2+y, hairHL);
      px(g, headX+6, headTop+2, hairHL);
    } else {
      for (let x=headX; x<headX+8; x++) px(g, x, headTop+1, hairMain);
    }
  }
  function face() {
    if (dir === 3) {
      px(g, headX+2, headTop+3, eyes);
      px(g, headX+5, headTop+3, eyes);
    } else {
      px(g, headX+2, headTop+4, eyes);
      px(g, headX+5, headTop+4, eyes);
      px(g, headX+3, headTop+6, "#aa6a6a");
    }
  }
  function torso(outfit, outfitSh) {
    for (let y=0; y<6; y++) {
      for (let x=0; x<8; x++) {
        const col = (y >= 2) ? outfitSh : outfit;
        px(g, bodyX+x, bodyTop+y, col);
      }
    }
    for (let x=bodyX; x<bodyX+8; x++) px(g, x, bodyTop+6, belt);
  }
  function arms(outfit) {
    const leftX  = bodyX-1, rightX = bodyX+8;
    const armTop = bodyTop+1;
    px(g, leftX, armTop, outfit);
    px(g, rightX, armTop, outfit);
    let ly = armTop + Math.round(armSwingL/2);
    let ry = armTop + Math.round(armSwingR/2);
    px(g, leftX, ly+1, skin);
    px(g, leftX, ly+2, skin);
    px(g, rightX, ry+1, skin);
    px(g, rightX, ry+2, skin);
  }
  function legs() {
    const legTop = bodyTop+7;
    const mid = bodyX+3;
    const lX = mid-2, rX = mid+2;
    const lOffset = Math.round(legSwingL/2);
    const rOffset = Math.round(legSwingR/2);
    px(g, lX, legTop + lOffset, palette.shadow);
    px(g, lX, legTop+1 + lOffset, palette.shadow);
    px(g, rX, legTop + rOffset, palette.shadow);
    px(g, rX, legTop+1 + rOffset, palette.shadow);
    px(g, lX, legTop+2 + lOffset, boots);
    px(g, lX, legTop+3 + lOffset, boots);
    px(g, rX, legTop+2 + rOffset, boots);
    px(g, rX, legTop+3 + rOffset, boots);
    if (dir === 1) {
      px(g, lX-1, legTop+3 + lOffset, boots);
    } else if (dir === 2) {
      px(g, rX+1, legTop+3 + rOffset, boots);
    } else {
      px(g, lX, legTop+4 + lOffset, boots);
      px(g, rX, legTop+4 + rOffset, boots);
    }
  }

  hairBack(palette.hair);
  headFront(palette.hair);
  face();
  torso(palette.main, palette.shadow);
  arms(palette.main);
  legs();

  if (dir === 3) px(g, bodyX+3, bodyTop, "#25a048"); // lil collar highlight
}

const framesAna = [[],[],[],[]];
const framesSilv = [[],[],[],[]];
const palAna = { hair: hairAna, main: outfitAna, shadow: outfitAnaShadow };
const palSilv = { hair: hairSilvio, main: outfitSilv, shadow: outfitSilvShadow };

for (let dir=0; dir<4; dir++) {
  for (let f=0; f<5; f++) {
    framesAna[dir][f]  = makeFrame(g => drawCharacter(g, dir, f, palAna));
    framesSilv[dir][f] = makeFrame(g => drawCharacter(g, dir, f, palSilv));
  }
}

/* ==========================================================
   Player (Ana)
   ========================================================== */
const player = {
  x: 120, y: 120,
  w: DRAW_W, h: DRAW_H,
  speed: 180,
  dir: 0,        // 0 down,1 left,2 right,3 up
  frame: 0,
  animTime: 0,
  animSpeed: 9,
  moving: false,
  hearts: 3,
  invuln: 0,     // damage cooldown
};

/* ==========================================================
   Sword (kept in-hand + swing animation)
   ========================================================== */
let swordSwing = {
  active: false,
  t: 0,           // 0..1 timeline
  duration: 0.18, // seconds
  reach: 38,      // pixels from hand
};
function playerAttack() {
  if (dialogActive) return; // blocked by dialog
  if (swordSwing.active) return;
  swordSwing.active = true;
  swordSwing.t = 0;
}
function drawSword() {
  // hand anchor near right side of torso
  const hand = { x: player.x + player.w/2 + 8, y: player.y + player.h/2 - 8 };
  // swing angle based on dir
  let startA = 0, endA = 0;
  switch (player.dir) {
    case 0: startA = Math.PI*0.15; endA = -Math.PI*0.65; break;    // down
    case 1: startA = Math.PI*0.85; endA = Math.PI*1.65; break;     // left
    case 2: startA = -Math.PI*0.15; endA = Math.PI*0.65; break;    // right
    case 3: startA = Math.PI*1.15; endA = Math.PI*0.35; break;     // up
  }
  const a = lerp(startA, endA, easeOutCubic(swordSwing.t));
  const tipX = hand.x + Math.cos(a) * swordSwing.reach;
  const tipY = hand.y + Math.sin(a) * swordSwing.reach;

  // Blade
  ctx.lineWidth = 6;
  ctx.lineCap = "round";
  ctx.strokeStyle = "#cfd7df";
  ctx.beginPath();
  ctx.moveTo(hand.x, hand.y);
  ctx.lineTo(tipX, tipY);
  ctx.stroke();

  // Hilt
  ctx.lineWidth = 8;
  ctx.strokeStyle = "#704a1f";
  ctx.beginPath();
  ctx.moveTo(hand.x - Math.cos(a+Math.PI/2)*6, hand.y - Math.sin(a+Math.PI/2)*6);
  ctx.lineTo(hand.x + Math.cos(a+Math.PI/2)*6, hand.y + Math.sin(a+Math.PI/2)*6);
  ctx.stroke();
}

/* ==========================================================
   NPC (Silvio) — fixed position in the middle
   ========================================================== */
const quest = {
  near: false,
  accepted: false,
  lines: [
    "Will you accept my quest, my love?"
  ],
  idx: 0
};
const promptEl = document.getElementById("prompt");
const dialogEl = document.getElementById("dialog");
const dlgName = document.getElementById("dlgName");
const dlgLine = document.getElementById("dlgLine");
let dialogActive = false;

function checkSilvioProximity() {
  const dx = (player.x + player.w/2) - (silvio.x + DRAW_W_SILV/2);
  const dy = (player.y + player.h/2) - (silvio.y + DRAW_H_SILV/2);
  const d2 = dx*dx + dy*dy;
  const near = d2 < (140*140);
  quest.near = near && !quest.accepted;
  promptEl.style.display = quest.near && !dialogActive ? "block" : "none";
}
function tryStartQuest() {
  if (!quest.near || dialogActive) return;
  dialogActive = true;
  player.moving = false; // lock movement
  dlgName.textContent = "Silvio";
  quest.idx = 0;
  dlgLine.textContent = quest.lines[quest.idx];
  dialogEl.style.display = "block";
}
function advanceDialog() {
  if (!dialogActive) return;
  quest.idx++;
  if (quest.idx >= quest.lines.length) {
    // End dialog
    dialogActive = false;
    dialogEl.style.display = "none";
    quest.accepted = true;
    // Do NOT rebuild or shuffle the map — nothing here touches map building.
  } else {
    dlgLine.textContent = quest.lines[quest.idx];
  }
}

/* ==========================================================
   Enemies (Zombies) + Coins
   ========================================================== */
const zombies = []; // {x,y,w,h,hp,speed,dir,knock}
const coins = [];   // {x,y,vx,vy,life,collectable}

function spawnZombie() {
  const side = Math.floor(Math.random()*4);
  let x=0,y=0;
  if (side===0) { x = 20; y = Math.random()*H; }
  if (side===1) { x = W-20; y = Math.random()*H; }
  if (side===2) { x = Math.random()*W; y = 20; }
  if (side===3) { x = Math.random()*W; y = H-20; }
  zombies.push({
    x, y,
    w: DRAW_W, h: DRAW_H,
    hp: 2,
    speed: 60 + Math.random()*30,
    dir: 0,
    knock: 0
  });
}
let zombieSpawnTimer = 0;

function updateZombies(dt) {
  for (let i=zombies.length-1; i>=0; i--) {
    const z = zombies[i];
    if (z.knock > 0) z.knock -= dt;

    // Chase Ana
    const dx = (player.x + player.w/2) - (z.x + z.w/2);
    const dy = (player.y + player.h/2) - (z.y + z.h/2);
    const d = Math.hypot(dx,dy) || 1;
    const vx = (dx/d) * z.speed;
    const vy = (dy/d) * z.speed;

    z.x += vx*dt*(z.knock>0 ? 0.2 : 1);
    z.y += vy*dt*(z.knock>0 ? 0.2 : 1);

    // Damage player if touch
    if (!dialogActive && rectsOverlap(z, player) && player.invuln <= 0) {
      player.hearts--;
      player.invuln = 1.0;
      if (player.hearts < 0) player.hearts = 0;
    }

    // Killed?
    if (z.hp <= 0) {
      // Drop coin exactly where zombie died
      coins.push({ x: z.x + z.w/2, y: z.y + z.h/2, vx: 0, vy: 0, life: 0, collectable: true });
      zombies.splice(i,1);
    }
  }

  zombieSpawnTimer -= dt;
  if (zombieSpawnTimer <= 0 && !dialogActive) {
    zombieSpawnTimer = 2.0 + Math.random()*1.0;
    spawnZombie();
  }
}

function drawZombie(z) {
  // Pixel zombie: tattered, bluish skin
  ctx.save();
  ctx.imageSmoothingEnabled = false;

  // Body block
  ctx.fillStyle = "#6db1b1"; // cold skin
  ctx.fillRect(Math.round(z.x)+18, Math.round(z.y)+16, 20, 16);
  // Head
  ctx.fillStyle = "#7fc3c3";
  ctx.fillRect(Math.round(z.x)+20, Math.round(z.y)+2, 16, 14);
  ctx.fillStyle = "#2a2a2a"; // eyes
  ctx.fillRect(Math.round(z.x)+24, Math.round(z.y)+6, 3, 3);
  ctx.fillRect(Math.round(z.x)+30, Math.round(z.y)+6, 3, 3);
  // Blood drips
  ctx.fillStyle = "#a11212";
  ctx.fillRect(Math.round(z.x)+20, Math.round(z.y)+14, 3, 3);
  ctx.fillRect(Math.round(z.x)+31, Math.round(z.y)+16, 2, 2);
  // Legs
  ctx.fillStyle = "#445";
  ctx.fillRect(Math.round(z.x)+20, Math.round(z.y)+32, 6, 10);
  ctx.fillRect(Math.round(z.x)+30, Math.round(z.y)+32, 6, 10);
  // Arms
  ctx.fillStyle = "#6db1b1";
  ctx.fillRect(Math.round(z.x)+14, Math.round(z.y)+18, 6, 6);
  ctx.fillRect(Math.round(z.x)+40, Math.round(z.y)+18, 6, 6);

  ctx.restore();
}

function updateCoins(dt) {
  for (let i=coins.length-1; i>=0; i--) {
    const c = coins[i];
    c.life += dt;
    // pickup if Ana overlaps
    const pickBox = { x: c.x-10, y: c.y-10, w: 20, h: 20 };
    if (c.collectable && rectsOverlap(pickBox, player)) {
      gold += 1;
      updateGoldHUD();
      coins.splice(i,1);
    }
  }
}

/* ==========================================================
   Rect collision helper (AABB)
   ========================================================== */
function rectsOverlap(a, b) {
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

/* ==========================================================
   Movement & Physics (player vs solids)
   ========================================================== */
function tryMove(dt, dx, dy) {
  const next = { x: player.x + dx, y: player.y + dy, w: player.w, h: player.h };
  const feet = { x: next.x + player.w*0.25, y: next.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };

  // screen bounds
  if (feet.x < 0) next.x = player.x;
  if (feet.y < 0) next.y = player.y;
  if (feet.x + feet.w > W) next.x = player.x;
  if (feet.y + feet.h > H) next.y = player.y;

  // solids (tree trunks)
  const solids = getSolids();
  for (const s of solids) {
    if (rectsOverlap(feet, s)) {
      const testX = { x: player.x + dx, y: player.y, w: player.w, h: player.h };
      const feetX = { x: testX.x + player.w*0.25, y: testX.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!rectsOverlap(feetX, s)) { player.x += dx; return; }
      const testY = { x: player.x, y: player.y + dy, w: player.w, h: player.h };
      const feetY = { x: testY.x + player.w*0.25, y: testY.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!rectsOverlap(feetY, s)) { player.y += dy; return; }
      return;
    }
  }

  // door: teleport if touch
  const doorBox = { x: door.x, y: door.y, w: door.w, h: door.h };
  if (rectsOverlap({ x: next.x, y: next.y, w: player.w, h: player.h }, doorBox)) {
    teleportToOtherWorld();
    return;
  }

  player.x = next.x;
  player.y = next.y;
}

function teleportToOtherWorld() {
  // Simple flash + reposition (keep snow world art — demo teleport)
  // You could swap to another prebuilt buffer if you want a second world.
  flash(180);
  player.x = Math.round(W/2 - player.w/2);
  player.y = Math.round(H*0.8 - player.h/2);
}

/* ==========================================================
   HUD (hearts + gold centered top)
   ========================================================== */
const heartsEl = document.getElementById("hearts");
const goldEl = document.getElementById("goldCount");
let gold = 0;

function updateHeartsHUD() {
  heartsEl.innerHTML = "";
  const maxHearts = 3;
  for (let i=0; i<maxHearts; i++) {
    const d = document.createElement("div");
    d.className = "heart" + (i < player.hearts ? "" : " off");
    heartsEl.appendChild(d);
  }
}
function updateGoldHUD() {
  goldEl.textContent = gold;
}

/* ==========================================================
   Small helpers
   ========================================================== */
function lerp(a,b,t){ return a + (b-a)*t; }
function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

/* Simple flash effect */
let flashTimer = 0;
function flash(ms) { flashTimer = ms/1000; }

/* ==========================================================
   Game loop
   ========================================================== */
let last = 0;
let running = false;

function update(dt) {
  // Lock movement if dialog is active
  if (dialogActive) {
    player.moving = false;
  } else {
    let vx = 0, vy = 0;
    if (keys.has("arrowleft") || keys.has("a")) vx -= 1;
    if (keys.has("arrowright")|| keys.has("d")) vx += 1;
    if (keys.has("arrowup")   || keys.has("w")) vy -= 1;
    if (keys.has("arrowdown") || keys.has("s")) vy += 1;

    player.moving = (vx !== 0 || vy !== 0);
    if (player.moving) {
      const len = Math.hypot(vx, vy) || 1;
      vx /= len; vy /= len;
      if (Math.abs(vx) > Math.abs(vy)) player.dir = (vx < 0) ? 1 : 2;
      else if (Math.abs(vy) > 0)      player.dir = (vy < 0) ? 3 : 0;
      tryMove(dt, vx * player.speed * dt, vy * player.speed * dt);
    }
  }

  // Anim
  if (player.moving) {
    player.animTime += dt * player.animSpeed;
    const step = Math.floor(player.animTime) % 4;
    player.frame = 1 + step;
  } else {
    player.animTime = 0;
    player.frame = 0;
  }

  // Sword swing anim
  if (swordSwing.active) {
    swordSwing.t += dt / swordSwing.duration;
    if (swordSwing.t >= 1) {
      swordSwing.t = 1;
      swordSwing.active = false;
    } else {
      // Hit-test zombies while swinging
      swordHitCheck();
    }
  }

  if (player.invuln > 0) player.invuln -= dt;

  // Enemies + coins
  updateZombies(dt);
  updateCoins(dt);

  // Prompt near Silvio
  checkSilvioProximity();

  // Flash decay
  if (flashTimer > 0) flashTimer -= dt;

  // Update HUD
  updateHeartsHUD();
}

function swordHitCheck() {
  // Approximate the sword arc as a circle near player's hand
  const hand = { x: player.x + player.w/2 + 8, y: player.y + player.h/2 - 8 };
  for (const z of zombies) {
    const zx = z.x + z.w/2, zy = z.y + z.h/2;
    const d = Math.hypot(zx - hand.x, zy - hand.y);
    if (d < swordSwing.reach + 16) {
      z.hp -= 1;
      z.knock = 0.2;
    }
  }
}

function render() {
  // World
  ctx.drawImage(mapBuffer, 0, 0);

  // Silvio (fixed, centered-ish)
  const silvImg = framesSilv[silvio.dir || 0][0];
  ctx.drawImage(silvImg, 0,0, BASE_W, BASE_H, Math.round(silvio.x), Math.round(silvio.y), DRAW_W_SILV, DRAW_H_SILV);

  // Ana
  const img = framesAna[player.dir][player.frame];
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img, 0,0, BASE_W, BASE_H, Math.round(player.x), Math.round(player.y), DRAW_W, DRAW_H);
  ctx.restore();

  // Sword always in hand (and swings)
  drawSword();

  // Zombies
  for (const z of zombies) drawZombie(z);

  // Coins
  for (const c of coins) {
    ctx.fillStyle = "#ffd54a";
    ctx.beginPath();
    ctx.arc(c.x, c.y, 6, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#fff1a8";
    ctx.fillRect(c.x-1, c.y-3, 2, 6);
  }

  // Flash
  if (flashTimer > 0) {
    ctx.fillStyle = `rgba(255,255,255,${Math.min(1, flashTimer*1.2)})`;
    ctx.fillRect(0,0,W,H);
  }
}

function loop(ts) {
  if (!running) return;
  const dt = Math.min(0.033, (ts - last) / 1000 || 0);
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

/* ==========================================================
   Start
   ========================================================== */
const startOverlay = document.getElementById("startOverlay");
document.getElementById("startBtn").addEventListener("click", () => {
  startOverlay.style.display = "none";
  running = true;
  last = performance.now();
  requestAnimationFrame(loop);
});

/* ==========================================================
   Init
   ========================================================== */
resize();
// place player somewhere central
player.x = (W - DRAW_W)/2;
player.y = (H - DRAW_H)/2;
updateHeartsHUD();
updateGoldHUD();

/* ==========================================================
   Notes on the requested FIXES (already applied in code):
   - Map no longer reshuffles after accepting the quest:
     We use a deterministic RNG (MAP_SEED) and precompute
     all map features (trees/flowers/rocks/drifts) ONCE.
     buildStaticSnowMap() is called only during initial
     resize. Accepting the quest never rebuilds the map.
   - Silvio has a fixed position near the middle:
     placeFixedWorldThings() pins his coordinates based on
     canvas size, not random. We never change them later.
   - Door stays fixed in the top-right corner:
     drawDoorOnMap() sets door.x/y using current W/H with
     a margin; it’s redrawn with the buffer so it remains
     anchored to the corner. Teleport logic is separate.
   - HUD "Gold:" is centered at the very top (.hud).
   - Sword stays in Ana’s hand and has a proper swing arc.
   - Coins drop exactly where the zombie dies.
=========================================================== */
</script>
</body>
</html>
