<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Adventure</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000;
  }
  /* Start overlay */
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 5;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
  }
  #startBtn:active { transform: translateY(1px); }

  /* Quest / dialogue box */
  #dialogue {
    position: fixed;
    left: 50%;
    bottom: 8vh;
    transform: translateX(-50%);
    min-width: min(90vw, 800px);
    max-width: 95vw;
    background: rgba(0,0,0,0.85);
    color:#fff;
    border: 2px solid #fff;
    border-radius: 10px;
    padding: 14px 16px;
    font-size: clamp(14px, 2.1vw, 18px);
    line-height: 1.35;
    display: none;
    z-index: 6;
  }
  #dialogue .hint {
    display:block;
    opacity: .8;
    margin-top: 8px;
    font-size: .9em;
  }

  /* Soft HUD for hearts/gold */
  #hud {
    position: fixed;
    left: 10px; /* moved further to the left */
    top: 10px;
    color: #fff;
    font-size: 16px;
    z-index: 4;
    text-shadow: 0 2px 0 rgba(0,0,0,.5);
    user-select: none;
  }
  #hud .row { display: flex; align-items:center; gap:10px; margin-bottom:4px; }
  #hud .heart { width: 18px; height: 16px; image-rendering: pixelated; }
  #hud .coinIcon { width: 14px; height: 14px; image-rendering: pixelated; margin-right: 4px; }
  #hud .count { font-family: monospace; font-weight: 700; letter-spacing:.5px; }

  /* Interact prompt over NPC / Door */
  #prompt {
    position: fixed;
    left: 50%;
    transform: translateX(-50%);
    bottom: 18vh;
    color: #fff;
    background: rgba(0,0,0,.7);
    border: 1px solid #fff;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: clamp(12px,2vw,16px);
    display: none;
    z-index: 5;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="startOverlay">
  <div id="title">Pixel Adventure</div>
  <button id="startBtn">Start Game</button>
</div>

<div id="dialogue"></div>
<div id="prompt"></div>

<!-- HUD -->
<div id="hud">
  <div class="row" id="heartsRow"></div>
  <div class="row">
    <canvas id="coinIcon" class="coinIcon" width="14" height="14"></canvas>
    <span class="count" id="goldCount">x0</span>
  </div>
</div>

<script>
/* =========================================================
   Basic engine + sizing
   ========================================================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;

function resize() {
  W = canvas.width  = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  ctx.imageSmoothingEnabled = false;
  buildStaticMap(); // rebuild for current map type
}
window.addEventListener("resize", resize);

/* =========================================================
   Input handling
   ========================================================= */
const keys = new Set();
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "];
  if (moveKeys.includes(k)) e.preventDefault();
  keys.add(k);

  // Space => attack (if not in dialogue and not already swinging)
  if (k === " " && running && !ui.dialogOpen && !player.swing.active) {
    startSwing();
  }
  // E => interact (NPC / Door)
  if (k === "e" && running && !player.swing.active) {
    tryInteract();
  }
});
window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

/* =========================================================
   UI helpers (dialogue, prompt)
   ========================================================= */
const ui = {
  promptEl: document.getElementById("prompt"),
  dialogueEl: document.getElementById("dialogue"),
  dialogOpen: false,
  showPrompt(text) {
    this.promptEl.textContent = text;
    this.promptEl.style.display = "block";
  },
  hidePrompt() { this.promptEl.style.display = "none"; },
  showDialogue(text, hint) {
    this.dialogOpen = true;
    this.dialogueEl.innerHTML = text + (hint ? `<span class="hint">${hint}</span>` : "");
    this.dialogueEl.style.display = "block";
  },
  hideDialogue() {
    this.dialogOpen = false;
    this.dialogueEl.style.display = "none";
  }
};

/* =========================================================
   Random helpers
   ========================================================= */
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

/* =========================================================
   Map system: 2 maps
   - "grass": intro with Silvio + door to snow
   - "snow": combat map with zombies/coins
   ========================================================= */
let mapBuffer, mapCtx;
let solidRects = []; // collision solids (trunks/rocks/door frame)
let currentMap = "grass"; // start in grass
let doorRect = { x: 0, y: 0, w: 40, h: 60 };
let silvio = null; // npc in grass map
let coins = [];    // coin pickups
let zombies = [];  // enemies on snow map
let maxZombies = 8; // limited number

function buildStaticMap() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  solidRects = [];
  coins = [];

  if (currentMap === "grass") buildGrassMap();
  else buildSnowMap();
}

/* ---------- Grass Map (intro + Silvio + Door) ---------- */
function buildGrassMap() {
  // Base grass
  mapCtx.fillStyle = "#6ac36a";
  mapCtx.fillRect(0,0,W,H);

  // Grass noise
  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = Math.random();
      if (v < 0.18) { mapCtx.fillStyle = "#64bb64"; mapCtx.fillRect(x,y,cell,cell); }
      else if (v < 0.28) { mapCtx.fillStyle = "#71cd71"; mapCtx.fillRect(x,y,cell,cell); }
    }
  }

  // Flowers
  const flowerCount = Math.floor((W*H)/12000);
  for (let i=0;i<flowerCount;i++){
    const x = randi(8,W-8), y=randi(8,H-8), type=randi(0,3);
    mapCtx.fillStyle = (type===0)?"#ffe6f2":(type===1)?"#fff8a6":"#b0e3ff";
    mapCtx.fillRect(x,y,3,3); mapCtx.fillRect(x+2,y+1,2,2); mapCtx.fillRect(x-1,y+1,2,2);
    mapCtx.fillStyle="#2f7b2f"; mapCtx.fillRect(x+1,y+3,1,3);
  }

  // Trees
  const treeCount = Math.floor((W*H)/50000);
  for (let i=0;i<treeCount;i++){ const x=randi(60,W-60), y=randi(60,H-60); drawTree(mapCtx,x,y); }

  // Place Silvio (top-right quadrant area)
  const sx = Math.floor(W*0.78), sy = Math.floor(H*0.18);
  silvio = makeNPC("Silvio", sx, sy, "right"); // slight to top-right, not at pure corner

  // Draw a stone arch door (teleport to snow)
  const dw = 54, dh = 78;
  const dx = Math.floor(W*0.12), dy = Math.floor(H*0.72);
  drawDoor(mapCtx, dx, dy, dw, dh);
  doorRect = { x: dx+8, y: dy+18, w: dw-16, h: dh-18 };
  solidRects.push({x: dx, y: dy+dh-8, w: dw, h: 8}); // base stone as solid
}

/* ---------- Snow Map (combat) ---------- */
function buildSnowMap() {
  // Base snow
  mapCtx.fillStyle = "#e9f3ff";
  mapCtx.fillRect(0,0,W,H);

  // Snow noise patches
  for (let i=0;i<Math.floor((W*H)/4000);i++){
    const x = randi(0,W), y=randi(0,H), r=randi(18,40);
    mapCtx.fillStyle = (i%2? "#f6fbff":"#dfeefe");
    mapCtx.beginPath(); mapCtx.arc(x,y,r,0,Math.PI*2); mapCtx.fill();
  }

  // Frosty pines + rocks as solids
  const pineCount = Math.floor((W*H)/70000);
  for (let i=0;i<pineCount;i++){
    const x=randi(60,W-60), y=randi(60,H-60);
    drawPine(mapCtx,x,y);
  }
  const rockCount = Math.floor((W*H)/120000);
  for (let i=0;i<rockCount;i++){
    const x=randi(40,W-40), y=randi(40,H-40);
    drawRock(mapCtx,x,y);
  }

  // Spawn limited zombies
  zombies = [];
  for (let i=0;i<maxZombies;i++){
    zombies.push(makeZombie(
      randi(60,W-60),
      randi(60,H-60),
      randi(0,3)
    ));
  }
}

/* ---------- Map decoration helpers ---------- */
function drawTree(g, x, y) {
  g.fillStyle = "#2e8b57";
  for (let r = 26; r >= 18; r -= 4) { g.beginPath(); g.arc(x, y, r, 0, Math.PI*2); g.fill(); }
  g.fillStyle = "#3da86e"; g.beginPath(); g.arc(x-8, y-8, 10, 0, Math.PI*2); g.fill();
  const trunkW = 14, trunkH = 26; const tx = x - trunkW/2, ty = y + 10;
  g.fillStyle = "#8b5a2b"; g.fillRect(tx, ty, trunkW, trunkH);
  g.fillStyle = "#a06c38"; g.fillRect(tx+4, ty+2, 4, trunkH-4);
  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}
function drawPine(g, x, y) {
  // snowy pine
  const layers = 3;
  for (let i=0;i<layers;i++){
    const w = 56 - i*14, h = 22;
    g.fillStyle = "#2a5b3a";
    g.beginPath(); g.moveTo(x, y+i*16);
    g.lineTo(x - w/2, y + i*16 + h); g.lineTo(x + w/2, y + i*16 + h); g.closePath(); g.fill();
    // snow cap
    g.fillStyle="#ffffff"; g.fillRect(x - w/4, y+i*16 + 3, w/2, 3);
  }
  // trunk
  g.fillStyle="#7b5530"; g.fillRect(x-6, y+layers*16, 12, 20);
  solidRects.push({x:x-6,y:y+layers*16,w:12,h:20});
}
function drawRock(g,x,y){
  g.fillStyle="#9aa5b1"; g.beginPath(); g.ellipse(x,y,18,12,0,0,Math.PI*2); g.fill();
  solidRects.push({x:x-14,y:y-6,w:28,h:14});
}
function drawDoor(g,x,y,w,h){
  // stone arch
  g.fillStyle="#6d6e70"; g.fillRect(x, y, w, h);
  g.clearRect(x+8,y+18,w-16,h-18); // opening
  // snow tint
  g.fillStyle="rgba(255,255,255,0.2)"; g.fillRect(x,y, w, 10);
}

/* =========================================================
   Character sprite builder (Ana + Silvio + Zombies)
   Terraria-ish 8-bit look, base 16x24, scale x4
   Directions: 0=down,1=left,2=right,3=up
   Frames: 0 idle, 1..4 walk, special swing frames for Ana
   ========================================================= */
const BASE_W = 16, BASE_H = 24;
const SCALE = 4; // 16x24 -> 64x96
const DRAW_W = BASE_W * SCALE;
const DRAW_H = BASE_H * SCALE;

function makeFrame(drawFn) {
  const c = document.createElement("canvas");
  c.width = BASE_W; c.height = BASE_H;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;
  drawFn(g);
  return c;
}
function p(g, x, y, color) { g.fillStyle = color; g.fillRect(x, y, 1, 1); }

// Palettes
const skin      = "#f0c8a8";
const hair      = "#5a3a21";
const hairHL    = "#6b482b";
const eyes      = "#2a2a2a";
const outfitG   = "#1f8a3c";   // Ana outfit main (green)
const outfitGd  = "#166a2e";
const boots     = "#4b3928";
const belt      = "#2e2e2e";

const outfitB   = "#1d4d8f";   // Silvio outfit (blue)
const outfitBd  = "#163c6e";
const hairSilv  = "#4d321a";

// Zombie palette
const zSkin     = "#a7d1a7";   // pale green
const zShadow   = "#8ab78a";
const zEyes     = "#1b1b1b";
const zBlood    = "#9b1c1c";
const zClothA   = "#556b2f";   // dull shirt
const zClothB   = "#3f4a2a";

// Sword palette
const blade     = "#d7d7d7";
const bladeHi   = "#ffffff";
const hilt      = "#a07b3f";
const hiltDark  = "#8a6a36";

/* ---------- Core body painters ---------- */
function drawHumanoid(g, dir, frameIndex, colors, addGlasses=false, taller=false, muscular=false, withSword=false, swingPose=null) {
  g.clearRect(0,0,BASE_W,BASE_H);

  // Offsets
  const walkFrames = [
    {legL: -2, legR: 2, armL: 2, armR: -2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 2,  legR: -2, armL: -2, armR: 2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0},
    {headY:-1, bodyY:0, arm:-1},
    {headY:-1, bodyY:0, arm:1},
    {headY:0, bodyY:-1, arm:0},
  ];
  const isIdle = (frameIndex === 0);
  let headY=0, bodyY=0, armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;

  if (isIdle) { const ip = idlePose[dir]; headY=ip.headY; bodyY=ip.bodyY; armSwingL=ip.arm; armSwingR=-ip.arm; }
  else { const w = walkFrames[(frameIndex-1)%4]; armSwingL=w.armL; armSwingR=w.armR; legSwingL=w.legL; legSwingR=w.legR; }

  // Dimensions
  const headX = 3;
  let headTop = 2 + headY;
  const bodyTop = 12 + bodyY - (taller?1:0);
  const bodyX = 3;

  // Hair back
  const hairCol = colors.hair || hair;
  for (let x=2; x<=13; x++) p(g,x,headTop, hairCol);
  for (let x=1; x<=14; x++) p(g,x,headTop+1, hairCol);
  for (let x=1; x<=14; x++) p(g,x,headTop+2, hairCol);
  for (let x=1; x<=14; x++) p(g,x,headTop+3, hairCol);
  for (let x=2; x<=13; x++) p(g,x,headTop+4, hairCol);
  p(g,2, headTop+5, hairCol); p(g,13, headTop+5, hairCol);

  // Head
  const skinCol = colors.skin || skin;
  for (let y=0; y<8+(taller?1:0); y++)
    for (let x=0; x<8; x++) p(g, headX+x, headTop+1+y, skinCol);
  for (let x=headX+1; x<=headX+6; x++) p(g, x, headTop+9+(taller?1:0), skinCol);

  // Hair front / bangs
  const hh = colors.hairHL || hairHL;
  if (dir===0) { p(g, headX, headTop+1, hh); p(g, headX+7, headTop+1, hh); p(g, headX+2, headTop+1, hairCol); p(g, headX+5, headTop+1, hairCol); }
  else if (dir===1) { for (let y=0;y<6;y++) p(g, headX, headTop+2+y, hh); p(g, headX+1, headTop+2, hh); }
  else if (dir===2) { for (let y=0;y<6;y++) p(g, headX+7, headTop+2+y, hh); p(g, headX+6, headTop+2, hh); }
  else { for (let x=headX; x<headX+8; x++) p(g, x, headTop+1, hairCol); }

  // Face
  const eyesCol = colors.eyes || eyes;
  if (dir===3){ p(g, headX+2, headTop+3, eyesCol); p(g, headX+5, headTop+3, eyesCol); }
  else {
    p(g, headX+2, headTop+4, eyesCol); p(g, headX+5, headTop+4, eyesCol);
    p(g, headX+3, headTop+6, "#aa6a6a");
  }
  // Round glasses for Ana
  if (addGlasses && dir!==3) {
    g.fillStyle = "#000";
    g.fillRect(headX+1, headTop+3, 1, 1);
    g.fillRect(headX+4, headTop+3, 1, 1);
    g.fillRect(headX+1, headTop+5, 1, 1);
    g.fillRect(headX+4, headTop+5, 1, 1);
    g.fillRect(headX+2, headTop+4, 1, 1);
    g.fillRect(headX+3, headTop+4, 1, 1);
  }

  // Torso
  const torsoMain = colors.top || outfitG;
  const torsoShade= colors.topD|| outfitGd;
  const width = muscular? 9:8;
  for (let y=0; y<6+(taller?1:0); y++) {
    for (let x=0; x<width; x++) {
      const col = (y>=2)? torsoShade:torsoMain;
      p(g, bodyX+x, bodyTop+y, col);
    }
  }
  for (let x=bodyX; x<bodyX+width; x++) p(g, x, bodyTop+6+(taller?1:0), belt);

  // Arms
  const leftX  = bodyX-1, rightX = bodyX+width;
  const armTop = bodyTop+1;
  p(g, leftX, armTop, torsoMain); p(g, rightX, armTop, torsoMain);
  let ly = armTop + Math.round(armSwingL/2);
  let ry = armTop + Math.round(armSwingR/2);
  p(g, leftX, ly+1, skinCol); p(g, leftX, ly+2, skinCol);
  p(g, rightX, ry+1, skinCol); p(g, rightX, ry+2, skinCol);

  // Legs + Boots
  const legTop = bodyTop+7+(taller?0:0);
  const mid = bodyX+Math.floor(width/2);
  const lX = mid-2, rX = mid+2;
  const lOffset = Math.round(legSwingL/2);
  const rOffset = Math.round(legSwingR/2);
  const legCol = torsoShade;
  p(g, lX, legTop + lOffset, legCol); p(g, lX, legTop+1 + lOffset, legCol);
  p(g, rX, legTop + rOffset, legCol); p(g, rX, legTop+1 + rOffset, legCol);
  p(g, lX, legTop+2 + lOffset, boots); p(g, lX, legTop+3 + lOffset, boots);
  p(g, rX, legTop+2 + rOffset, boots); p(g, rX, legTop+3 + rOffset, boots);
  if (dir===1) p(g, lX-1, legTop+3 + lOffset, boots);
  else if (dir===2) p(g, rX+1, legTop+3 + rOffset, boots);
  else { p(g, lX, legTop+4 + lOffset, boots); p(g, rX, legTop+4 + rOffset, boots); }

  // Collar highlight up-facing
  if (dir === 3) p(g, bodyX+3, bodyTop, (colors.collarHi||"#25a048"));

  // Sword (always in hand) or swing
  if (withSword) {
    if (swingPose) drawSwordSwing(g, dir, swingPose);
    else drawSwordIdle(g, dir);
  }
}

/* ---------- Sword: idle-in-hand + swing poses ---------- */
function drawSwordIdle(g, dir) {
  // small blade that "sits" by the right hand for right-facing, etc.
  g.fillStyle = hilt; // hilt
  if (dir===0){ g.fillRect(11, 16, 2, 2); g.fillStyle=blade; g.fillRect(13, 15, 1, 6); g.fillStyle=bladeHi; g.fillRect(13, 15, 1, 1); }
  else if (dir===1){ g.fillRect(1, 15, 2, 2); g.fillStyle=blade; g.fillRect(0, 13, 6, 1); g.fillStyle=bladeHi; g.fillRect(0, 13, 1, 1); }
  else if (dir===2){ g.fillRect(13, 15, 2, 2); g.fillStyle=blade; g.fillRect(15, 13, 6, 1); }
  else { g.fillRect(11, 6, 2, 2); g.fillStyle=blade; g.fillRect(13, 4, 1, 6); }
}
function drawSwordSwing(g, dir, pose) {
  // pose: 0..3 (windup -> impact -> follow -> recover)
  // Weâ€™ll arc the blade around the character
  g.fillStyle = hilt;
  const drawPixel = (x,y,c)=>{ g.fillStyle=c; g.fillRect(x,y,1,1); };

  if (dir===0){ // facing down: arc right -> down
    if (pose===0){ drawPixel(12,13,hilt); drawPixel(13,12,blade); drawPixel(14,11,bladeHi); }
    if (pose===1){ drawPixel(13,16,hilt); drawPixel(14,15,blade); drawPixel(15,14,bladeHi); drawPixel(12,17,blade); }
    if (pose===2){ drawPixel(12,18,hilt); drawPixel(12,19,blade); drawPixel(11,20,bladeHi); drawPixel(13,19,blade); }
    if (pose===3){ drawPixel(10,17,hilt); drawPixel(9,17,blade); drawPixel(8,16,bladeHi); }
  } else if (dir===1){ // left
    if (pose===0){ drawPixel(4,14,hilt); drawPixel(3,13,blade); drawPixel(2,12,bladeHi); }
    if (pose===1){ drawPixel(2,14,hilt); drawPixel(1,14,blade); drawPixel(0,14,bladeHi); drawPixel(3,15,blade); }
    if (pose===2){ drawPixel(1,16,hilt); drawPixel(1,17,blade); drawPixel(1,18,bladeHi); drawPixel(2,15,blade); }
    if (pose===3){ drawPixel(3,18,hilt); drawPixel(4,18,blade); drawPixel(5,18,bladeHi); }
  } else if (dir===2){ // right
    if (pose===0){ drawPixel(11,14,hilt); drawPixel(12,13,blade); drawPixel(13,12,bladeHi); }
    if (pose===1){ drawPixel(14,14,hilt); drawPixel(15,14,blade); drawPixel(16,14,bladeHi); drawPixel(13,15,blade); }
    if (pose===2){ drawPixel(15,16,hilt); drawPixel(15,17,blade); drawPixel(15,18,bladeHi); drawPixel(14,15,blade); }
    if (pose===3){ drawPixel(13,18,hilt); drawPixel(12,18,blade); drawPixel(11,18,bladeHi); }
  } else { // up
    if (pose===0){ drawPixel(12,6,hilt); drawPixel(13,5,blade); drawPixel(14,4,bladeHi); }
    if (pose===1){ drawPixel(12,4,hilt); drawPixel(12,3,blade); drawPixel(12,2,bladeHi); drawPixel(11,5,blade); }
    if (pose===2){ drawPixel(10,4,hilt); drawPixel(9,4,blade); drawPixel(8,4,bladeHi); drawPixel(11,5,blade); }
    if (pose===3){ drawPixel(9,6,hilt); drawPixel(9,7,blade); drawPixel(9,8,bladeHi); }
  }
}

/* ---------- Specific builders ---------- */
function makeAnaFrames() {
  const frames = [[],[],[],[]];
  for (let dir=0; dir<4; dir++){
    for (let f=0; f<5; f++){
      frames[dir][f] = makeFrame((g)=>drawHumanoid(g, dir, f,
        { skin, hair, hairHL, eyes, top:outfitG, topD:outfitGd, collarHi:"#25a048" },
        true/*glasses*/, false/*taller*/, false/*muscular*/, true/*withSword*/
      ));
    }
  }
  // swing overlays as separate sprites (pose 0..3)
  const swing = [[],[],[],[]];
  for (let dir=0; dir<4; dir++){
    for (let pose=0; pose<4; pose++){
      swing[dir][pose] = makeFrame((g)=>drawHumanoid(g, dir, 0,
        { skin, hair, hairHL, eyes, top:outfitG, topD:outfitGd, collarHi:"#25a048" },
        true, false, false, true, pose
      ));
    }
  }
  return { walk: frames, swing };
}
function makeSilvioFrames() {
  const frames = [[],[],[],[]];
  for (let dir=0; dir<4; dir++){
    for (let f=0; f<5; f++){
      frames[dir][f] = makeFrame((g)=>drawHumanoid(g, dir, f,
        { skin, hair:hairSilv, hairHL:"#5d3a21", eyes, top:outfitB, topD:outfitBd, collarHi:"#2a6cc9" },
        false, true/*taller*/, true/*muscular*/, false
      ));
    }
  }
  return frames;
}
function makeZombieFrames() {
  const frames = [[],[],[],[]];
  for (let dir=0; dir<4; dir++){
    for (let f=0; f<5; f++){
      frames[dir][f] = makeFrame((g)=>{
        // base as humanoid but spooky colors, tattered & blood
        drawHumanoid(g, dir, f, { skin:zSkin, hair:"#2d2d2d", hairHL:"#3b3b3b", eyes:zEyes, top:zClothA, topD:zClothB }, false,false,false,false);
        // blood spatters
        p(g, 7, 15, zBlood); p(g, 6, 16, zBlood); p(g, 4, 18, zBlood);
        // rag edges
        p(g, 3, 18, "#2f2f2f"); p(g, 10, 17, "#2f2f2f");
      });
    }
  }
  return frames;
}

const anaSprites = makeAnaFrames();
const silvioSprites = makeSilvioFrames();
const zombieSprites = makeZombieFrames();

/* =========================================================
   Entities
   ========================================================= */
const player = {
  name: "Ana",
  x: 120, y: 120,
  w: DRAW_W, h: DRAW_H,
  speed: 180, // px/sec
  dir: 0, // 0 down,1 left,2 right,3 up
  frame: 0,
  animTime: 0,
  animSpeed: 9,
  moving: false,
  hearts: 3,
  invuln: 0,
  gold: 0,
  swing: { active:false, t:0, frame:0, total:0.28 }, // seconds, 4 poses
};
function makeNPC(name, x, y, facing="down"){
  return { name, x, y, dir: (facing==="down"?0:facing==="left"?1:facing==="right"?2:3), w:DRAW_W, h:DRAW_H };
}
function makeZombie(x,y,dir=0){
  return { x, y, dir, w:DRAW_W, h:DRAW_H, speed: 70, frame:0, animTime:0, alive:true, hitCd:0, hp:2 };
}
function makeCoin(x,y){
  return { x, y, r: 8, vy: -120, life: 0, pickup:false };
}

/* =========================================================
   Collision helpers
   ========================================================= */
function rectsOverlap(a, b) { return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }
function feetBox(ent){
  return { x: ent.x + ent.w*0.25, y: ent.y + ent.h*0.65, w: ent.w*0.5, h: ent.h*0.3 };
}

/* =========================================================
   Sword swing & combat
   ========================================================= */
function startSwing(){
  player.swing.active = true;
  player.swing.t = 0;
  player.swing.frame = 0;
}
function swordHitbox(dir){
  // a small box in front of Ana depending on swing phase
  const f = player.swing.frame; // 0..3
  const px = player.x, py = player.y;
  const w = 30, h = 30;
  if (dir===0) return { x: px+DRAW_W/2 - 
