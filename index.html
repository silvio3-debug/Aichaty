<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Game for Princess</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Apple Color Emoji, Segoe UI Emoji, Noto Color Emoji, "Twemoji Mozilla", "Segoe UI Symbol", "Android Emoji", "EmojiSymbols";
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000; /* will be covered by map render */
  }

  /* Overlays (start/prompt/dialog/gameover/HUD share some basics) */
  .overlay,
  .prompt,
  .dialog,
  .gameover,
  .hud {
    position: fixed;
    inset: 0;
    pointer-events: none;
  }

  /* Start overlay */
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 1000;
    pointer-events: auto;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
    user-select: none;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
    pointer-events: auto;
  }
  #startBtn:active { transform: translateY(1px); }

  /* Prompt bubble (“Press E to accept quest”) */
  .prompt {
    display:none;
    z-index: 20;
  }
  .prompt .bubble {
    position: absolute;
    transform: translate(-50%, -100%);
    background: rgba(0,0,0,0.75);
    color: #fff;
    border: 2px solid #fff;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 14px;
    pointer-events: none;
    white-space: nowrap;
  }

  /* Dialog box (non-skippable until finished) */
  .dialog {
    display:none;
    z-index: 30;
  }
  .dialog .box {
    position: absolute;
    left: 50%;
    bottom: 8%;
    transform: translateX(-50%);
    width: min(90vw, 700px);
    background: rgba(0,0,0,0.85);
    border: 2px solid #fff;
    border-radius: 12px;
    color: #fff;
    padding: 16px 18px;
    line-height: 1.45;
    font-size: clamp(14px, 2vw, 18px);
    pointer-events: auto;
  }
  .dialog .continue {
    display:block;
    margin-top: 10px;
    font-size: 12px;
    opacity: 0.85;
    user-select: none;
  }

  /* Game Over overlay */
  .gameover {
    display: none;
    z-index: 50;
  }
  .gameover .center {
    position: absolute;
    left:50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.88);
    color: #fff;
    border: 2px solid #fff;
    border-radius: 12px;
    padding: 18px 20px;
    text-align: center;
    width: min(90vw, 420px);
    pointer-events: auto;
  }
  .gameover .center h2 {
    margin: 6px 0 10px 0;
    font-size: 22px;
  }
  .gameover .center button {
    margin-top: 12px;
    background:#fff;
    color:#000;
    border: none;
    padding: 10px 14px;
    border-radius: 8px;
    cursor: pointer;
  }

  /* HUD (Hearts + Gold) — FIXED: center the gold at the very top */
  .hud {
    top: 10px; width: 100%; transform: none; left: 0; display:flex; justify-content: center; align-items: center; padding: 0 12px;
    z-index: 40;
    pointer-events: none;
  }
  /* keep hearts on the left while gold stays centered */
  #hearts { position: absolute; left: 12px; top: 10px; }

  .hud .gold {
    background: rgba(0,0,0,0.72);
    color: #fff;
    border: 2px solid #fff;
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 14px;
    line-height: 1;
    user-select: none;
  }
  .hud .hearts {
    display:flex;
    gap: 6px;
  }
  .hud .heart {
    width: 18px;
    height: 18px;
    background: #c9223a;
    border: 2px solid #fff;
    border-radius: 4px;
    box-shadow: 0 0 0 2px rgba(0,0,0,0.4) inset;
  }
  .hud .heart.empty {
    background: rgba(0,0,0,0.4);
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<!-- HUD -->
<div class="hud" aria-hidden="true">
  <div id="hearts" class="hearts"></div>
  <div id="gold" class="gold">Gold: 0</div>
</div>

<!-- NPC prompt bubble -->
<div id="prompt" class="prompt" aria-hidden="true">
  <div id="promptBubble" class="bubble">Press E to accept quest</div>
</div>

<!-- Dialog box -->
<div id="dialog" class="dialog" aria-hidden="true">
  <div class="box" id="dialogBox">
    <div id="dialogText">Will you accept my quest my love?</div>
    <span class="continue" id="dialogContinue">Press Space to continue</span>
  </div>
</div>

<!-- Start overlay -->
<div id="startOverlay">
  <div id="title">Pixel Adventure</div>
  <button id="startBtn">Start Game</button>
</div>

<!-- Game Over overlay -->
<div id="gameOver" class="gameover" aria-hidden="true">
  <div class="center">
    <h2>Game Over</h2>
    <p>Press the button to restart.</p>
    <button id="restartBtn">Restart</button>
  </div>
</div>

<script>
/* =========================
   Basic engine + sizing
   ========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;

function resize() {
  W = canvas.width  = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  ctx.imageSmoothingEnabled = false;
  buildSnowMap(); // snow world builder
  rebuildHearts();
}
window.addEventListener("resize", resize);

/* =========================
   Input handling
   ========================= */
const keys = new Set();
let lastPressedKey = null;
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "];
  if (moveKeys.includes(k)) e.preventDefault();
  keys.add(k);
  lastPressedKey = k;
});
window.addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

/* =========================
   Random helpers
   ========================= */
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

/* =========================
   Snow Map (static, full screen)
   ========================= */
let mapBuffer, mapCtx;
let solidRects = []; // collision solids (tree trunks)
let portalDoor = { x: 0, y: 0, w: 42, h: 56 };

function buildSnowMap() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  // Base snow
  mapCtx.fillStyle = "#dfe8f3";
  mapCtx.fillRect(0,0,W,H);

  // Subtle snow noise tiles
  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = Math.random();
      if (v < 0.12) {
        mapCtx.fillStyle = "#d7e0eb";
        mapCtx.fillRect(x, y, cell, cell);
      } else if (v < 0.20) {
        mapCtx.fillStyle = "#e9f2fc";
        mapCtx.fillRect(x, y, cell, cell);
      }
    }
  }

  // Snowy puffs
  const puffCount = Math.floor((W*H) / 70000);
  for (let i = 0; i < puffCount; i++) {
    const x = randi(12, W-12);
    const y = randi(12, H-12);
    mapCtx.fillStyle = "#ffffff";
    mapCtx.beginPath();
    mapCtx.arc(x, y, randi(6,12), 0, Math.PI*2);
    mapCtx.fill();
    mapCtx.fillStyle = "#cbd6e2";
    mapCtx.beginPath();
    mapCtx.arc(x-4, y-2, randi(3,8), 0, Math.PI*2);
    mapCtx.fill();
  }

  // Snowy trees
  solidRects = [];
  const treeCount = Math.floor((W*H) / 50000);
  for (let i = 0; i < treeCount; i++) {
    const x = randi(60, W-60);
    const y = randi(60, H-60);
    drawSnowTree(mapCtx, x, y);
  }

  // Portal door near top-right area (not exactly in the corner)
  portalDoor.x = Math.floor(W * 0.82);
  portalDoor.y = Math.floor(H * 0.15);
  drawPortal(mapCtx, portalDoor.x, portalDoor.y, portalDoor.w, portalDoor.h);
}

function drawSnowTree(g, x, y) {
  // Foliage (evergreen with snow caps)
  g.fillStyle = "#2f6b4f";
  for (let r = 26; r >= 18; r -= 4) {
    g.beginPath();
    g.arc(x, y, r, 0, Math.PI*2);
    g.fill();
  }
  // Snow caps
  g.fillStyle = "#ffffff";
  g.beginPath();
  g.arc(x-6, y-10, 8, 0, Math.PI*2);
  g.fill();

  // Trunk (solid rect)
  const trunkW = 14, trunkH = 26;
  const tx = x - trunkW/2, ty = y + 10;
  g.fillStyle = "#8b5a2b";
  g.fillRect(tx, ty, trunkW, trunkH);
  g.fillStyle = "#a06c38";
  g.fillRect(tx+4, ty+2, 4, trunkH-4);

  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}

function drawPortal(g, x, y, w, h) {
  // little snow shrine door
  g.save();
  g.translate(x, y);
  g.fillStyle = "#4d4f83";
  g.fillRect(0, 0, w, h);
  g.fillStyle = "#c9d2ff";
  g.fillRect(6, 6, w-12, h-12);
  // glow
  g.globalAlpha = 0.25;
  g.fillStyle = "#8fb0ff";
  g.fillRect(-4, -4, w+8, h+8);
  g.restore();
}

/* =========================
   Character sprite builders (Ana + Silvio + Zombies)
   Directions: 0=down,1=left,2=right,3=up
   Frames: idle(0), walk1(1), walk2(2), walk3(3), walk4(4)
   ========================= */
const BASE_W = 16, BASE_H = 24;
const SCALE = 4;
const DRAW_W = BASE_W * SCALE;
const DRAW_H = BASE_H * SCALE;

function makeFrame(drawFn) {
  const c = document.createElement("canvas");
  c.width = BASE_W; c.height = BASE_H;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;
  drawFn(g);
  return c;
}
function p(g, x, y, color) { g.fillStyle = color; g.fillRect(x, y, 1, 1); }

/* ===== Ana palette ===== */
const ANA = {
  skin: "#f0c8a8",
  hair: "#5a3a21",
  hairHL: "#6b482b",
  eyes: "#2a2a2a",
  outfitMain: "#1f8a3c",
  outfitShadow: "#166a2e",
  boots: "#4b3928",
  belt: "#2e2e2e",
  sword: "#c9c9c9",
  swordEdge: "#f2f2f2",
  swordGrip: "#4b3928",
};

/* ===== Silvio palette (taller/more muscular, brown hair, different outfit color) ===== */
const SILVIO = {
  skin: "#e8c09a",
  hair: "#6b3f1f",
  hairHL: "#7b4a27",
  eyes: "#1e1e1e",
  outfitMain: "#245a9b",   // blue
  outfitShadow: "#1b4a7f",
  boots: "#3c2e22",
  belt: "#1f1f1f",
};

/* ===== Zombie palette (pixel gore) ===== */
const ZOMBIE = {
  skin: "#9bb38d",
  shadow: "#7f9971",
  eyes: "#1a1a1a",
  teeth: "#f0f0f0",
  blood: "#8b0000",
  shirt: "#5d5d5d",
  pants: "#3a3a3a",
  boots: "#2b2b2b"
};

function drawHumanoid(g, pal, dir, frameIndex, tall = false, muscular = false, withSword=false, swordPhase=0) {
  g.clearRect(0,0,BASE_W,BASE_H);
  // walk offsets
  const walkFrames = [
    {legL: -2, legR: 2, armL: 2, armR: -2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 2,  legR: -2, armL: -2, armR: 2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0},
    {headY:-1, bodyY:0, arm:-1},
    {headY:-1, bodyY:0, arm:1},
    {headY:0, bodyY:-1, arm:0},
  ];
  const isIdle = (frameIndex === 0);
  let headY=0, bodyY=0, armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;
  if (isIdle) {
    const ip = idlePose[dir];
    headY = ip.headY; bodyY = ip.bodyY;
    armSwingL = ip.arm; armSwingR = -ip.arm;
  } else {
    const w = walkFrames[(frameIndex-1) % 4];
    armSwingL = w.armL; armSwingR = w.armR;
    legSwingL = w.legL; legSwingR = w.legR;
  }

  // base anchors
  let headTop = 2 + headY;
  let bodyTop = 12 + bodyY;
  const bodyX = 3;
  // tall/muscular tweaks
  if (tall) { headTop -= 1; bodyTop -= 1; }

  // hair back
  (function(){
    const col = pal.hair || "#444";
    for (let x=2; x<=13; x++) p(g,x,headTop, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+1, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+2, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+3, col);
    for (let x=2; x<=13; x++) p(g,x,headTop+4, col);
    p(g,2, headTop+5, col); p(g,13, headTop+5, col);
  })();

  // head + face
  (function(){
    const skin = pal.skin || "#f0c8a8";
    for (let y=0; y<8; y++) for (let x=0; x<8; x++) p(g, 3+x, headTop+1+y, skin);
    for (let x=4; x<=9; x++) p(g, x, headTop+9, skin);

    const hairHL = pal.hairHL || pal.hair;
    if (dir === 0) { p(g, 3, headTop+1, hairHL); p(g, 10, headTop+1, hairHL); }
    else if (dir === 1) { for (let y=0; y<6; y++) p(g, 3, headTop+2+y, hairHL); }
    else if (dir === 2) { for (let y=0; y<6; y++) p(g, 10, headTop+2+y, hairHL); }
    else { for (let x=3; x<11; x++) p(g, x, headTop+1, pal.hair || "#444"); }

    const eyes = pal.eyes || "#2a2a2a";
    if (dir === 3) { p(g, 5, headTop+3, eyes); p(g, 8, headTop+3, eyes); }
    else { p(g, 5, headTop+4, eyes); p(g, 8, headTop+4, eyes); p(g, 6, headTop+6, "#aa6a6a"); }
  })();

  // torso
  (function(){
    const main = pal.outfitMain || "#1f8a3c";
    const sh   = pal.outfitShadow || "#166a2e";
    const w = muscular ? 9 : 8;
    for (let y=0; y<6; y++) for (let x=0; x<w; x++) p(g, bodyX+x, bodyTop+y, (y >= 2) ? sh : main);
    // belt
    const belt = pal.belt || "#2e2e2e";
    for (let x=bodyX; x<bodyX+w; x++) p(g, x, bodyTop+6, belt);
  })();

  // arms
  (function(){
    const leftX  = 2, rightX = 12;
    const armTop = bodyTop+1;
    const main = pal.outfitMain || "#1f8a3c";
    const skin = pal.skin || "#f0c8a8";

    p(g, leftX, armTop, main);
    p(g, rightX, armTop, main);

    let ly = armTop + Math.round(armSwingL/2);
    let ry = armTop + Math.round(armSwingR/2);

    p(g, leftX, ly+1, skin);
    p(g, leftX, ly+2, skin);
    p(g, rightX, ry+1, skin);
    p(g, rightX, ry+2, skin);

    // sword in right hand (always in hand), multi-frame swing (phase 0..3)
    if (withSword) {
      // small sword pixels relative to right hand
      const grip = pal.swordGrip || "#4b3928";
      const blade = pal.sword || "#c9c9c9";
      const edge = pal.swordEdge || "#f2f2f2";
      // anchor near right hand
      let sx = rightX, sy = ry+2;
      if (dir === 0) { // down
        if (swordPhase === 0) { p(g, sx, sy, grip); p(g, sx+1, sy-1, blade); p(g, sx+2, sy-2, edge); }
        if (swordPhase === 1) { p(g, sx, sy, grip); p(g, sx+1, sy, blade); p(g, sx+2, sy, edge); }
        if (swordPhase === 2) { p(g, sx, sy, grip); p(g, sx, sy+1, blade); p(g, sx, sy+2, edge); }
        if (swordPhase === 3) { p(g, sx, sy, grip); p(g, sx-1, sy, blade); p(g, sx-2, sy, edge); }
      } else if (dir === 1) { // left
        if (swordPhase === 0) { p(g, sx, sy, grip); p(g, sx-1, sy-1, blade); p(g, sx-2, sy-2, edge); }
        if (swordPhase === 1) { p(g, sx, sy, grip); p(g, sx-1, sy, blade); p(g, sx-2, sy, edge); }
        if (swordPhase === 2) { p(g, sx, sy, grip); p(g, sx, sy+1, blade); p(g, sx, sy+2, edge); }
        if (swordPhase === 3) { p(g, sx, sy, grip); p(g, sx+1, sy, blade); p(g, sx+2, sy, edge); }
      } else if (dir === 2) { // right
        if (swordPhase === 0) { p(g, sx, sy, grip); p(g, sx+1, sy-1, blade); p(g, sx+2, sy-2, edge); }
        if (swordPhase === 1) { p(g, sx, sy, grip); p(g, sx+1, sy, blade); p(g, sx+2, sy, edge); }
        if (swordPhase === 2) { p(g, sx, sy, grip); p(g, sx, sy+1, blade); p(g, sx, sy+2, edge); }
        if (swordPhase === 3) { p(g, sx, sy, grip); p(g, sx-1, sy, blade); p(g, sx-2, sy, edge); }
      } else { // up
        if (swordPhase === 0) { p(g, sx, sy, grip); p(g, sx, sy-1, blade); p(g, sx, sy-2, edge); }
        if (swordPhase === 1) { p(g, sx, sy, grip); p(g, sx-1, sy-1, blade); p(g, sx-2, sy-2, edge); }
        if (swordPhase === 2) { p(g, sx, sy, grip); p(g, sx-1, sy, blade); p(g, sx-2, sy, edge); }
        if (swordPhase === 3) { p(g, sx, sy, grip); p(g, sx, sy+1, blade); p(g, sx, sy+2, edge); }
      }
    }
  })();

  // legs/boots
  (function(){
    const legTop = bodyTop+7;
    const mid = 6;
    const lX = mid-2, rX = mid+2;
    const lOffset = Math.round(legSwingL/2);
    const rOffset = Math.round(legSwingR/2);
    const sh = pal.outfitShadow || "#166a2e";
    const boots = pal.boots || "#4b3928";

    p(g, lX, legTop + lOffset, sh);
    p(g, lX, legTop+1 + lOffset, sh);
    p(g, rX, legTop + rOffset, sh);
    p(g, rX, legTop+1 + rOffset, sh);

    p(g, lX, legTop+2 + lOffset, boots);
    p(g, lX, legTop+3 + lOffset, boots);
    p(g, rX, legTop+2 + rOffset, boots);
    p(g, rX, legTop+3 + rOffset, boots);

    if (dir === 1) p(g, lX-1, legTop+3 + lOffset, boots);
    else if (dir === 2) p(g, rX+1, legTop+3 + rOffset, boots);
    else { p(g, lX, legTop+4 + lOffset, boots); p(g, rX, legTop+4 + rOffset, boots); }
  })();

  if (dir === 3 && pal.outfitMain) p(g, 6, bodyTop, pal.outfitMain);
}

function drawZombie(g, dir, frameIndex) {
  g.clearRect(0,0,BASE_W,BASE_H);
  const walkFrames = [
    {legL: -1, legR: 1, armL: 1, armR: -1},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 1,  legR: -1, armL: -1, armR: 1},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const isIdle = (frameIndex === 0);
  let armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;
  if (!isIdle) {
    const w = walkFrames[(frameIndex-1) % 4];
    armSwingL = w.armL; armSwingR = w.armR;
    legSwingL = w.legL; legSwingR = w.legR;
  }

  const headTop = 4, bodyTop = 13, bodyX = 3;

  // head (sickly green + blood smears)
  for (let y=0; y<7; y++) for (let x=0; x<8; x++) p(g, 4+x, headTop+y, ZOMBIE.skin);
  p(g, 5, headTop+3, ZOMBIE.eyes);
  p(g, 10, headTop+3, ZOMBIE.eyes);
  p(g, 7, headTop+5, ZOMBIE.teeth);
  p(g, 8, headTop+5, ZOMBIE.teeth);
  // blood
  p(g, 4, headTop+2, ZOMBIE.blood);
  p(g, 11, headTop+1, ZOMBIE.blood);

  // torso (torn shirt)
  for (let y=0; y<6; y++) for (let x=0; x<8; x++) p(g, bodyX+x, bodyTop+y, ZOMBIE.shirt);
  p(g, 6, bodyTop+2, ZOMBIE.blood);
  p(g, 7, bodyTop+4, ZOMBIE.blood);

  // arms
  const leftX  = 2, rightX = 12;
  const armTop = bodyTop+1;
  const ly = armTop + Math.round(armSwingL/2);
  const ry = armTop + Math.round(armSwingR/2);
  p(g, leftX, ly, ZOMBIE.shirt);
  p(g, rightX, ry, ZOMBIE.shirt);
  p(g, leftX, ly+1, ZOMBIE.skin);
  p(g, rightX, ry+1, ZOMBIE.skin);

  // legs
  const legTop = bodyTop+7;
  const mid = 6;
  const lX = mid-2, rX = mid+2;
  const lOffset = Math.round(legSwingL/2);
  const rOffset = Math.round(legSwingR/2);
  for (let y=0; y<2; y++) p(g, lX, legTop+y+lOffset, ZOMBIE.pants), p(g, rX, legTop+y+rOffset, ZOMBIE.pants);
  p(g, lX, legTop+2+lOffset, ZOMBIE.boots);
  p(g, rX, legTop+2+rOffset, ZOMBIE.boots);
}

const anaFrames = [[],[],[],[]];
const silvioFrames = [[],[],[],[]];
const zombieFrames = [[],[],[],[]];

for (let dir = 0; dir < 4; dir++) {
  for (let f = 0; f < 5; f++) {
    anaFrames[dir][f] = makeFrame((g) => drawHumanoid(g, ANA, dir, f, false, false, true, 0));
    silvioFrames[dir][f] = makeFrame((g) => drawHumanoid(g, SILVIO, dir, f, true, true, false, 0));
    zombieFrames[dir][f] = makeFrame((g) => drawZombie(g, dir, f));
  }
}

/* =========================
   Player (Ana)
   ========================= */
const player = {
  x: 120, y: 120,
  w: DRAW_W, h: DRAW_H,
  speed: 180,
  dir: 0,
  frame: 0,
  animTime: 0,
  animSpeed: 9,
  moving: false,
  hearts: 3,
  swordSwinging: false,
  swordTimer: 0,
  swordPhase: 0
};

/* =========================
   NPC (Silvio)
   ========================= */
const silvio = {
  name: "Silvio",
  x: 0, y: 0,
  w: DRAW_W, h: DRAW_H,
  dir: 0,
};
function placeSilvioTopRight() {
  silvio.x = Math.floor(W * 0.78);
  silvio.y = Math.floor(H * 0.18);
  // keep inside screen
  if (silvio.x + silvio.w > W-10) silvio.x = W - silvio.w - 10;
  if (silvio.y + silvio.h > H-10) silvio.y = H - silvio.h - 10;
}

/* =========================
   Zombies + Combat
   ========================= */
const zombies = [];
function spawnZombie() {
  const edge = randi(0,4);
  let zx, zy;
  if (edge === 0) { zx = randi(0, W); zy = -DRAW_H; }
  else if (edge === 1) { zx = randi(0, W); zy = H + DRAW_H; }
  else if (edge === 2) { zx = -DRAW_W; zy = randi(0, H); }
  else { zx = W + DRAW_W; zy = randi(0, H); }

  zombies.push({
    x: zx, y: zy,
    w: DRAW_W, h: DRAW_H,
    speed: 70 + Math.random()*40,
    dir: 0,
    frame: 0,
    animTime: 0,
    animSpeed: 6,
    hp: 2
  });
}
function damagePlayer() {
  if (player.hearts > 0) {
    player.hearts -= 1;
    rebuildHearts();
    if (player.hearts <= 0) {
      showGameOver();
    }
  }
}

/* =========================
   Coins + Gold (FIXED: stay where zombie dies)
   ========================= */
let gold = 0;
const coins = [];
function dropCoin(x, y) {
  coins.push({x, y, r: 8});
}
function updateCoins(dt) {
  // coins stay where they dropped; only handle pickup
  if (!coins.length) return;
  for (let i = coins.length - 1; i >= 0; i--) {
    const c = coins[i];
    const dx = (player.x + player.w*0.5) - c.x;
    const dy = (player.y + player.h*0.8) - c.y;
    const dist = Math.hypot(dx, dy);
    if (dist < 36) {
      gold += 1;
      goldEl.innerText = `Gold: ${gold}`;
      coins.splice(i,1);
    }
  }
}

/* =========================
   Axis-aligned rect collision helper
   ========================= */
function rectsOverlap(a, b) {
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

function tryMove(dt, dx, dy) {
  const next = { x: player.x + dx, y: player.y + dy, w: player.w, h: player.h };
  const feet = { x: next.x + player.w*0.25, y: next.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };

  // screen bounds
  if (feet.x < 0) next.x = player.x; 
  if (feet.y < 0) next.y = player.y; 
  if (feet.x + feet.w > W) next.x = player.x; 
  if (feet.y + feet.h > H) next.y = player.y;

  // solids (trees)
  for (const s of solidRects) {
    if (rectsOverlap(feet, s)) {
      const testX = { x: player.x + dx, y: player.y, w: player.w, h: player.h };
      const feetX = { x: testX.x + player.w*0.25, y: testX.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!rectsOverlap(feetX, s)) { player.x += dx; return; }
      const testY = { x: player.x, y: player.y + dy, w: player.w, h: player.h };
      const feetY = { x: testY.x + player.w*0.25, y: testY.y + player.h*0.65, w: player.w*0.5, h: player.w*0.3 };
      if (!rectsOverlap(feetY, s)) { player.y += dy; return; }
      return;
    }
  }

  player.x = next.x;
  player.y = next.y;
}

/* =========================
   HUD elements
   ========================= */
const goldEl = document.getElementById("gold");
const heartsEl = document.getElementById("hearts");
function rebuildHearts() {
  heartsEl.innerHTML = "";
  for (let i=0; i<3; i++) {
    const d = document.createElement("div");
    d.className = "heart" + (i < player.hearts ? "" : " empty");
    heartsEl.appendChild(d);
  }
}

/* =========================
   Prompt & Dialog (Silvio)
   ========================= */
const promptEl = document.getElementById("prompt");
const promptBubble = document.getElementById("promptBubble");
const dialogEl = document.getElementById("dialog");
const dialogText = document.getElementById("dialogText");

let nearSilvio = false;
let inDialog = false;
let dialogFinished = false;

function showPromptAt(x, y, text = "Press E to accept quest") {
  promptBubble.textContent = text;
  promptEl.style.display = "block";
  // position above Silvio
  promptBubble.style.left = `${x + DRAW_W/2}px`;
  promptBubble.style.top  = `${y}px`;
}
function hidePrompt() { promptEl.style.display = "none"; }

function showDialog(text) {
  dialogText.textContent = text;
  dialogEl.style.display = "block";
  inDialog = true;
}
function hideDialog() {
  dialogEl.style.display = "none";
  inDialog = false;
  dialogFinished = true;
}

/* =========================
   Game Over
   ========================= */
const gameOverEl = document.getElementById("gameOver");
const restartBtn = document.getElementById("restartBtn");
restartBtn.addEventListener("click", () => {
  location.reload();
});
function showGameOver() {
  running = false;
  gameOverEl.style.display = "block";
}

/* =========================
   Game loop, movement & combat
   ========================= */
let last = 0;
let running = false;

function handleInput(dt) {
  // Block all movement when dialog is up
  if (inDialog) return;

  let vx = 0, vy = 0;
  if (keys.has("arrowleft") || keys.has("a")) vx -= 1;
  if (keys.has("arrowright")|| keys.has("d")) vx += 1;
  if (keys.has("arrowup")   || keys.has("w")) vy -= 1;
  if (keys.has("arrowdown") || keys.has("s")) vy += 1;

  player.moving = (vx !== 0 || vy !== 0);
  if (player.moving) {
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;

    if (Math.abs(vx) > Math.abs(vy)) player.dir = (vx < 0) ? 1 : 2;
    else if (Math.abs(vy) > 0)       player.dir = (vy < 0) ? 3 : 0;

    const dx = vx * player.speed * dt;
    const dy = vy * player.speed * dt;
    tryMove(dt, dx, dy);
  }

  // Sword swing (space) — always in hand, animated phases
  if (!inDialog && (keys.has(" "))) {
    if (!player.swordSwinging) {
      player.swordSwinging = true;
      player.swordTimer = 0;
      player.swordPhase = 0;
    }
  }
}

function updatePlayerAnim(dt) {
  if (player.moving) {
    player.animTime += dt * player.animSpeed;
    const step = Math.floor(player.animTime) % 4;
    player.frame = 1 + step;
  } else {
    player.animTime = 0;
    player.frame = 0;
  }

  if (player.swordSwinging) {
    player.swordTimer += dt;
    // 4 phases across ~0.25s
    if      (player.swordTimer < 0.06) player.swordPhase = 0;
    else if (player.swordTimer < 0.12) player.swordPhase = 1;
    else if (player.swordTimer < 0.18) player.swordPhase = 2;
    else if (player.swordTimer < 0.24) player.swordPhase = 3;
    else { player.swordSwinging = false; player.swordTimer = 0; player.swordPhase = 0; }
  }
}

function attackHitbox() {
  // small hitbox in front of Ana based on direction
  const range = 28;
  let hx = player.x + player.w/2 - 12;
  let hy = player.y + player.h/2 - 12;
  if (player.dir === 0) hy += range;
  if (player.dir === 3) hy -= range;
  if (player.dir === 1) hx -= range;
  if (player.dir === 2) hx += range;
  return { x: hx, y: hy, w: 24, h: 24 };
}

function updateZombies(dt) {
  // Spawn occasionally
  if (Math.random() < 0.02 && zombies.length < 12) spawnZombie();

  const hit = attackHitbox();
  for (let i = zombies.length - 1; i >= 0; i--) {
    const z = zombies[i];
    // move toward player
    const cx = (player.x + player.w/2) - (z.x + z.w/2);
    const cy = (player.y + player.h/2) - (z.y + z.h/2);
    const len = Math.hypot(cx, cy) || 1;
    const vx = (cx / len) * z.speed * dt;
    const vy = (cy / len) * z.speed * dt;
    z.x += vx; z.y += vy;
    // choose facing
    if (Math.abs(cx) > Math.abs(cy)) z.dir = (cx < 0) ? 1 : 2;
    else z.dir = (cy < 0) ? 3 : 0;

    // anim
    z.animTime += dt * z.animSpeed;
    z.frame = 1 + (Math.floor(z.animTime) % 4);

    // collide with player (damage)
    const zfeet = { x: z.x + z.w*0.25, y: z.y + z.h*0.7, w: z.w*0.5, h: z.h*0.3 };
    const pfeet = { x: player.x + player.w*0.25, y: player.y + player.h*0.7, w: player.w*0.5, h: player.h*0.3 };
    if (rectsOverlap(zfeet, pfeet)) damagePlayer();

    // sword hit detection
    if (player.swordSwinging) {
      const zh = { x: z.x, y: z.y, w: z.w, h: z.h };
      if (rectsOverlap(hit, zh)) {
        z.hp -= 1;
        if (z.hp <= 0) {
          // Drop coin exactly where zombie dies (no fall)
          const zx = z.x + z.w/2;
          const zy = z.y + z.h*0.85;
          dropCoin(zx, zy);
          zombies.splice(i,1);
          continue;
        }
      }
    }
  }
}

function updateSilvio(dt) {
  // Check proximity for prompt
  const px = player.x + player.w/2;
  const py = player.y + player.h*0.8;
  const sx = silvio.x + silvio.w/2;
  const sy = silvio.y + silvio.h*0.8;
  const dist = Math.hypot(px - sx, py - sy);

  if (!dialogFinished) {
    if (dist < 140) {
      nearSilvio = true;
      showPromptAt(silvio.x + silvio.w/2, silvio.y, "Press E to accept quest");
      // Accept quest -> show dialog, freeze player
      if (keys.has("e")) {
        hidePrompt();
        showDialog("Will you accept my quest my love?");
      }
    } else {
      nearSilvio = false;
      hidePrompt();
    }
  } else {
    hidePrompt();
  }
}

function updatePortal(dt) {
  // teleport if player overlaps portal (after dialog finished)
  if (!dialogFinished) return;
  const feet = { x: player.x + player.w*0.25, y: player.y + player.h*0.7, w: player.w*0.5, h: player.h*0.3 };
  const door = { x: portalDoor.x, y: portalDoor.y, w: portalDoor.w, h: portalDoor.h };
  if (rectsOverlap(feet, door)) {
    // Example teleport: move Ana to center
    player.x = (W - player.w)/2;
    player.y = (H - player.h)/2;
  }
}

function update(dt) {
  // Dialog progression (cannot move until space to continue)
  if (inDialog) {
    // waiting for space to finish
    if (keys.has(" ")) hideDialog();
    return;
  }

  handleInput(dt);
  updatePlayerAnim(dt);
  updateSilvio(dt);
  updateZombies(dt);
  updateCoins(dt);
  updatePortal(dt);
}

function render() {
  ctx.drawImage(mapBuffer, 0, 0);

  // Silvio
  const sImg = silvioFrames[silvio.dir][0];
  ctx.drawImage(sImg, 0,0, BASE_W, BASE_H, Math.round(silvio.x), Math.round(silvio.y), DRAW_W, DRAW_H);

  // Player (Ana) with sword animation
  const aImg = makeFrame(g => drawHumanoid(g, ANA, player.dir, player.frame, false, false, true, player.swordPhase));
  ctx.drawImage(aImg, 0,0, BASE_W, BASE_H, Math.round(player.x), Math.round(player.y), DRAW_W, DRAW_H);

  // Zombies
  for (const z of zombies) {
    const img = zombieFrames[z.dir][z.frame];
    ctx.drawImage(img, 0,0, BASE_W, BASE_H, Math.round(z.x), Math.round(z.y), DRAW_W, DRAW_H);
  }

  // Coins (simple circles)
  for (const c of coins) {
    ctx.save();
    ctx.fillStyle = "#f0d24a";
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#fff";
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();
  }
}

function loop(ts) {
  if (!running) return;
  const dt = Math.min(0.033, (ts - last) / 1000 || 0);
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

/* =========================
   Start overlay
   ========================= */
const startOverlay = document.getElementById("startOverlay");
document.getElementById("startBtn").addEventListener("click", () => {
  startOverlay.style.display = "none";
  running = true;
  last = performance.now();
  resize();
  placeSilvioTopRight();
  rebuildHearts();
  goldEl.innerText = `Gold: ${gold}`;
  requestAnimationFrame(loop);
});

/* =========================
   Init
   ========================= */
resize();
placeSilvioTopRight();
player.x = (W - DRAW_W)/2;
player.y = (H - DRAW_H)/2;

</script>
</body>
</html>
