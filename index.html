<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Adventure</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000; /* will be covered by map render */
  }
  /* Start overlay */
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 5;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
  }
  #startBtn:active { transform: translateY(1px); }

  /* HUD */
  .hud {
    position: fixed;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    color:#fff;
    font-size: clamp(14px, 2.2vw, 18px);
    z-index: 6;
    display:flex;
    align-items:center;
    gap: 14px;
    text-shadow: 0 1px 2px rgba(0,0,0,.6);
    pointer-events: none;
  }
  .hud .gold {
    display:flex;
    align-items:center;
    gap:6px;
  }
  .hud .gold .coin {
    width: 16px;
    height: 16px;
    background: radial-gradient(#ffd76a,#e0a800);
    border-radius:50%;
    box-shadow: 0 0 3px rgba(0,0,0,.5) inset;
  }
  .hud .hearts {
    display:flex;
    gap:4px;
  }
  .hud .hearts .heart {
    width:16px;height:16px;
    background: red;
    clip-path: polygon(50% 90%, 0% 40%, 15% 10%, 35% 10%, 50% 25%, 65% 10%, 85% 10%, 100% 40%);
    filter: drop-shadow(0 1px 1px rgba(0,0,0,.5));
  }

  /* Dialog */
  #dialog {
    position: fixed;
    left:50%;
    bottom: 6%;
    transform: translateX(-50%);
    width: min(800px, 88vw);
    background: rgba(0,0,0,.7);
    border: 1px solid rgba(255,255,255,.25);
    color:#fff;
    border-radius: 10px;
    padding: 14px 16px;
    z-index: 7;
    display:none;
    line-height: 1.35;
  }
  #dialog .name {
    font-weight: 700;
    margin-bottom: 6px;
    opacity: .95;
  }
  #dialog .text {
    white-space: pre-wrap;
  }
  #dialog .continue {
    margin-top: 10px;
    opacity: .8;
    font-size: .9em;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="startOverlay">
  <div id="title">Pixel Adventure</div>
  <button id="startBtn">Start Game</button>
</div>

<div class="hud" id="hud">
  <div class="gold"><div class="coin"></div><span id="goldCount">0</span></div>
  <div class="hearts" id="hearts"></div>
</div>

<div id="dialog">
  <div class="name" id="dlgName"></div>
  <div class="text" id="dlgText"></div>
  <div class="continue" id="dlgContinue">press Space to continue</div>
</div>

<script>
/* =========================
   Basic engine + sizing
   ========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;

function resize() {
  W = canvas.width  = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  ctx.imageSmoothingEnabled = false;
  // Rebuild map buffer to match new size
  buildStaticMap();
}
window.addEventListener("resize", resize);

/* =========================
   Input handling
   ========================= */
const keys = new Set();
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "];
  if (moveKeys.includes(k)) e.preventDefault();
  keys.add(k);
});
window.addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

/* =========================
   Random helpers + seeded RNG for stable maps
   ========================= */
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

let mapSeed = 1337; // stable until world changes or resize
function makeSeeded(seed) {
  let s = seed >>> 0;
  return () => {
    // xorshift32
    s ^= s << 13; s >>>= 0;
    s ^= s >> 17; s >>>= 0;
    s ^= s << 5;  s >>>= 0;
    return (s >>> 0) / 4294967296;
  };
}

/* =========================
   Map (static, full screen)
   ========================= */
let mapBuffer, mapCtx;
let solidRects = []; // collision solids (tree trunks)
let world = "grass"; // "grass" or "snow"
let questAccepted = false;

function buildStaticMap() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  // seeded RNG so it doesn't reshuffle on quest accept
  const rnd = makeSeeded(mapSeed);

  // Base
  if (world === "grass") {
    mapCtx.fillStyle = "#6ac36a";
  } else {
    mapCtx.fillStyle = "#d9eef7";
  }
  mapCtx.fillRect(0,0,W,H);

  // Subtle noise tiles
  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = rnd();
      if (world === "grass") {
        if (v < 0.18) {
          mapCtx.fillStyle = "#64bb64";
          mapCtx.fillRect(x, y, cell, cell);
        } else if (v < 0.28) {
          mapCtx.fillStyle = "#71cd71";
          mapCtx.fillRect(x, y, cell, cell);
        }
      } else {
        if (v < 0.25) {
          mapCtx.fillStyle = "#eaf6fc";
          mapCtx.fillRect(x, y, cell, cell);
        } else if (v < 0.35) {
          mapCtx.fillStyle = "#cfe7f3";
          mapCtx.fillRect(x, y, cell, cell);
        }
      }
    }
  }

  // Decorations
  solidRects = [];
  if (world === "grass") {
    const flowerCount = Math.floor((W*H) / 12000);
    for (let i = 0; i < flowerCount; i++) {
      const x = Math.floor(rnd()*(W-16))+8;
      const y = Math.floor(rnd()*(H-16))+8;
      const type = Math.floor(rnd()*3);
      if (type === 0) mapCtx.fillStyle = "#ffe6f2";
      if (type === 1) mapCtx.fillStyle = "#fff8a6";
      if (type === 2) mapCtx.fillStyle = "#b0e3ff";
      mapCtx.fillRect(x, y, 3, 3);
      mapCtx.fillRect(x+2, y+1, 2, 2);
      mapCtx.fillRect(x-1, y+1, 2, 2);
      mapCtx.fillStyle = "#2f7b2f";
      mapCtx.fillRect(x+1, y+3, 1, 3);
    }

    const treeCount = Math.floor((W*H) / 50000);
    for (let i = 0; i < treeCount; i++) {
      const x = Math.floor(rnd()*(W-120))+60;
      const y = Math.floor(rnd()*(H-120))+60;
      drawTree(mapCtx, x, y);
    }
  } else {
    // Snowy pines & snow piles
    const pineCount = Math.floor((W*H) / 60000);
    for (let i = 0; i < pineCount; i++) {
      const x = Math.floor(rnd()*(W-120))+60;
      const y = Math.floor(rnd()*(H-120))+60;
      drawPine(mapCtx, x, y);
    }
    const pileCount = Math.floor((W*H) / 80000);
    for (let i = 0; i < pileCount; i++) {
      const x = Math.floor(rnd()*(W-40))+20;
      const y = Math.floor(rnd()*(H-40))+20;
      mapCtx.fillStyle = "#ffffff";
      mapCtx.beginPath();
      mapCtx.arc(x, y, 10+Math.floor(rnd()*8), 0, Math.PI*2);
      mapCtx.fill();
    }
  }

  // Door not baked into map anymore—rendered at runtime if visible
}

function drawTree(g, x, y) {
  g.fillStyle = "#2e8b57";
  for (let r = 26; r >= 18; r -= 4) {
    g.beginPath();
    g.arc(x, y, r, 0, Math.PI*2);
    g.fill();
  }
  g.fillStyle = "#3da86e";
  g.beginPath();
  g.arc(x-8, y-8, 10, 0, Math.PI*2);
  g.fill();
  const trunkW = 14, trunkH = 26;
  const tx = x - trunkW/2, ty = y + 10;
  g.fillStyle = "#8b5a2b";
  g.fillRect(tx, ty, trunkW, trunkH);
  g.fillStyle = "#a06c38";
  g.fillRect(tx+4, ty+2, 4, trunkH-4);
  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}
function drawPine(g, x, y) {
  // simple layered pine
  g.fillStyle = "#2f5d3a";
  for (let i=0;i<4;i++){
    g.beginPath();
    g.moveTo(x, y - 30 + i*12);
    g.lineTo(x-20+i*4, y - 8 + i*12);
    g.lineTo(x+20-i*4, y - 8 + i*12);
    g.closePath();
    g.fill();
  }
  // trunk
  const trunkW = 12, trunkH = 22;
  const tx = x - trunkW/2, ty = y + 4;
  g.fillStyle = "#7b542e";
  g.fillRect(tx, ty, trunkW, trunkH);
  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}

/* =========================
   Character sprite builder (Ana + Silvio + Zombies)
   ========================= */
const BASE_W = 16, BASE_H = 24;
const SCALE = 4; // 16x24 -> 64x96 on screen
const DRAW_W = BASE_W * SCALE;
const DRAW_H = BASE_H * SCALE;

function makeFrame(drawFn) {
  const c = document.createElement("canvas");
  c.width = BASE_W; c.height = BASE_H;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;
  drawFn(g);
  return c;
}
function p(g, x, y, color) {
  g.fillStyle = color;
  g.fillRect(x, y, 1, 1);
}

/* ===== Palettes ===== */
const skin = "#f0c8a8";
const hair = "#5a3a21";
const hairHL = "#6b482b";
const eyes = "#2a2a2a";
const outfitMain = "#1f8a3c";
const outfitShadow = "#166a2e";
const boots = "#4b3928";
const belt = "#2e2e2e";

const silvioOutfit = "#2c4e98";
const silvioOutfitShadow = "#203b75";

/* draw humanoid with direction + frameIndex
   0=down,1=left,2=right,3=up
   frameIndex: 0 idle, 1..4 walking, 5..7 sword swing frames
*/
function drawCharacterBase(g, dir, frameIndex, palette, taller=false, muscular=false) {
  g.clearRect(0,0,BASE_W,BASE_H);
  const walkFrames = [
    {legL: -2, legR: 2, armL: 2, armR: -2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 2,  legR: -2, armL: -2, armR: 2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0},
    {headY:-1, bodyY:0, arm:-1},
    {headY:-1, bodyY:0, arm:1},
    {headY:0, bodyY:-1, arm:0},
  ];
  const isIdle = (frameIndex === 0);
  let headY=0, bodyY=0, armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;
  if (isIdle) {
    const ip = idlePose[dir];
    headY = ip.headY; bodyY = ip.bodyY;
    armSwingL = ip.arm; armSwingR = -ip.arm;
  } else if (frameIndex <= 4) {
    const w = walkFrames[(frameIndex-1) % 4];
    armSwingL = w.armL; armSwingR = w.armR;
    legSwingL = w.legL; legSwingR = w.legR;
  }

  const bodyScale = taller ? 2 : 0;
  const headX = 3, headTop = 2 + headY;
  const bodyTop = 12 + bodyY - (taller?1:0);
  const bodyX = 3;

  function drawHairBack() {
    const col = hair;
    for (let x=2; x<=13; x++) p(g,x,headTop, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+1, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+2, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+3, col);
    for (let x=2; x<=13; x++) p(g,x,headTop+4, col);
    p(g,2, headTop+5, col); p(g,13, headTop+5, col);
  }
  function drawHeadFront() {
    for (let y=0; y<8; y++) {
      for (let x=0; x<8; x++) p(g, headX+x, headTop+1+y, skin);
    }
    for (let x=headX+1; x<=headX+6; x++) p(g, x, headTop+9, skin);
    if (dir === 0) {
      p(g, headX, headTop+1, hairHL);
      p(g, headX+7, headTop+1, hairHL);
      p(g, headX+2, headTop+1, hair);
      p(g, headX+5, headTop+1, hair);
    } else if (dir === 1) {
      for (let y=0; y<6; y++) p(g, headX, headTop+2+y, hairHL);
      p(g, headX+1, headTop+2, hairHL);
    } else if (dir === 2) {
      for (let y=0; y<6; y++) p(g, headX+7, headTop+2+y, hairHL);
      p(g, headX+6, headTop+2, hairHL);
    } else {
      for (let x=headX; x<headX+8; x++) p(g, x, headTop+1, hair);
    }
  }
  function drawFace() {
    if (dir === 3) {
      p(g, headX+2, headTop+3, eyes);
      p(g, headX+5, headTop+3, eyes);
    } else {
      p(g, headX+2, headTop+4, eyes);
      p(g, headX+5, headTop+4, eyes);
      p(g, headX+3, headTop+6, "#aa6a6a");
    }
  }
  function drawTorso() {
    for (let y=0; y<6+bodyScale; y++) {
      for (let x=0; x<8+(muscular?1:0); x++) {
        const col = (y >= 2) ? palette.shadow : palette.main;
        p(g, bodyX+x-(muscular?0:0), bodyTop+y, col);
      }
    }
    for (let x=bodyX; x<bodyX+8; x++) p(g, x, bodyTop+6+bodyScale, belt);
  }
  function drawArms(withSwordAngle=null) {
    const leftX  = bodyX-1, rightX = bodyX+8;
    const armTop = bodyTop+1;
    p(g, leftX, armTop, palette.main);
    p(g, rightX, armTop, palette.main);
    let ly = armTop + Math.round(armSwingL/2);
    let ry = armTop + Math.round(armSwingR/2);
    p(g, leftX, ly+1, skin);
    p(g, leftX, ly+2, skin);
    p(g, rightX, ry+1, skin);
    p(g, rightX, ry+2, skin);

    // sword in right hand — stays attached + true swing frames (5..7)
    if (withSwordAngle !== null) {
      drawSword(g, rightX+1, ry+2, withSwordAngle);
    }
  }
  function drawLegsAndBoots() {
    const legTop = bodyTop+7+bodyScale;
    const mid = bodyX+3;
    const lX = mid-2, rX = mid+2;
    const lOffset = Math.round(legSwingL/2);
    const rOffset = Math.round(legSwingR/2);
    p(g, lX, legTop + lOffset, palette.shadow);
    p(g, lX, legTop+1 + lOffset, palette.shadow);
    p(g, rX, legTop + rOffset, palette.shadow);
    p(g, rX, legTop+1 + rOffset, palette.shadow);
    p(g, lX, legTop+2 + lOffset, boots);
    p(g, lX, legTop+3 + lOffset, boots);
    p(g, rX, legTop+2 + rOffset, boots);
    p(g, rX, legTop+3 + rOffset, boots);
    if (dir === 1) {
      p(g, lX-1, legTop+3 + lOffset, boots);
    } else if (dir === 2) {
      p(g, rX+1, legTop+3 + rOffset, boots);
    } else {
      p(g, lX, legTop+4 + lOffset, boots);
      p(g, rX, legTop+4 + rOffset, boots);
    }
  }

  drawHairBack();
  drawHeadFront();
  drawFace();
  drawTorso();

  // sword swing frames 5..7 with angles
  let swingAngle = null;
  if (frameIndex >= 5) {
    const phase = frameIndex - 5; // 0..2
    const angles = dir === 0 ? [20, 0, -20]
                 : dir === 1 ? [200, 180, 160]
                 : dir === 2 ? [-20, 0, 20]
                 : /*up*/      [340, 0, 20];
    swingAngle = angles[phase] * Math.PI/180;
  }
  drawArms(swingAngle);
  drawLegsAndBoots();
}

function drawSword(g, x, y, angleRad) {
  g.save();
  g.translate(x, y);
  if (angleRad !== null) g.rotate(angleRad);
  // hilt
  g.fillStyle = "#b08d57";
  g.fillRect(0, -1, 3, 2);
  // blade
  g.fillStyle = "#cfd9df";
  g.fillRect(3, -2, 7, 4);
  // tip
  g.fillRect(10, -1, 1, 2);
  g.restore();
}

function buildFrames(palette, taller=false, muscular=false) {
  const arr = [[],[],[],[]];
  for (let dir = 0; dir < 4; dir++) {
    // idle + walk 4 + swing 3 = 8 frames
    for (let f = 0; f < 8; f++) {
      arr[dir][f] = makeFrame((g) => drawCharacterBase(g, dir, f, palette, taller, muscular));
    }
  }
  return arr;
}

const anaFrames = buildFrames({main: outfitMain, shadow: outfitShadow}, false, false);
const silvioFrames = buildFrames({main: silvioOutfit, shadow: silvioOutfitShadow}, true, true);

// zombie palette
const zSkin = "#7ca07c";
const zBlood = "#8b0000";
const zOut = "#4a5f4a";
const zOutD = "#3a4a3a";
function buildZombieFrames() {
  const arr = [[],[],[],[]];
  for (let dir=0; dir<4; dir++) {
    for (let f=0; f<4; f++) {
      arr[dir][f] = makeFrame((g)=>{
        drawCharacterBase(g, dir, Math.min(f,4), {main:zOut,shadow:zOutD}, false, true);
        // add blood specks
        p(g, 7, 10, zBlood);
        p(g, 5, 12, zBlood);
      });
    }
  }
  return arr;
}
const zombieFrames = buildZombieFrames();

/* =========================
   Entities
   ========================= */
const player = {
  x: 120, y: 120,
  w: DRAW_W, h: DRAW_H,
  speed: 180, // px/sec
  dir: 0, // 0 down,1 left,2 right,3 up
  frame: 0,
  animTime: 0,
  animSpeed: 9,
  moving: false,
  swingTime: 0,
  maxHearts: 3,
  hearts: 3,
  gold: 0
};

const silvio = {
  x: 0, y: 0,
  w: DRAW_W, h: DRAW_H,
  dir: 0, frame: 0
};

const door = {
  x: 0, y: 0,
  w: 64, h: 96,
  visible: false
};

let coins = [];
let zombies = [];
let zombieSpawnTimer = 0;

/* =========================
   HUD + Dialog
   ========================= */
const hudGold = document.getElementById("goldCount");
const heartsEl = document.getElementById("hearts");
function setHUD() {
  hudGold.textContent = player.gold;
  heartsEl.innerHTML = "";
  for (let i=0;i<player.maxHearts;i++) {
    const div = document.createElement("div");
    div.className = "heart";
    if (i >= player.hearts) div.style.opacity = .3;
    heartsEl.appendChild(div);
  }
}
setHUD();

const dlg = {
  root: document.getElementById("dialog"),
  name: document.getElementById("dlgName"),
  text: document.getElementById("dlgText"),
  cont: document.getElementById("dlgContinue"),
  active: false,
  queue: [],
  onDone: null
};
function openDialog(lines, onDone) {
  dlg.queue = lines.slice();
  dlg.onDone = onDone || null;
  dlg.active = true;
  dlg.root.style.display = "block";
  nextDialogLine();
}
function nextDialogLine() {
  if (dlg.queue.length === 0) {
    dlg.active = false;
    dlg.root.style.display = "none";
    const cb = dlg.onDone;
    dlg.onDone = null;
    if (cb) cb();
    return;
  }
  const line = dlg.queue.shift();
  dlg.name.textContent = line.name || "";
  dlg.text.textContent = line.text || "";
}
window.addEventListener("keydown", (e)=>{
  if (!dlg.active) return;
  if (e.code === "Space") {
    e.preventDefault();
    nextDialogLine();
  }
});

/* =========================
   World placement helpers
   ========================= */
function placeDoor() {
  door.x = W - 120; // fixed near top-right
  door.y = 80;
}
function placeSilvio() {
  silvio.x = Math.floor((W - silvio.w) / 2);
  silvio.y = Math.floor((H - silvio.h) / 2);
}

/* =========================
   Collisions
   ========================= */
function rectsOverlap(a, b) {
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}
function feetRect(ent) {
  return { x: ent.x + ent.w*0.25, y: ent.y + ent.h*0.65, w: ent.w*0.5, h: ent.h*0.3 };
}
function tryMove(ent, dx, dy) {
  const next = { x: ent.x + dx, y: ent.y + dy, w: ent.w, h: ent.h };
  const feet = { x: next.x + ent.w*0.25, y: next.y + ent.h*0.65, w: ent.w*0.5, h: ent.h*0.3 };
  if (feet.x < 0 || feet.y < 0 || feet.x + feet.w > W || feet.y + feet.h > H) return;
  for (const s of solidRects) {
    if (rectsOverlap(feet, s)) return;
  }
  ent.x = next.x; ent.y = next.y;
}

/* =========================
   Coins
   ========================= */
function spawnCoin(x, y) {
  coins.push({x,y, w:16, h:16, vy:0, life: 9999});
}
function updateCoins(dt) {
  // coins sit where spawned; we keep life ticking
  for (const c of coins) {
    c.life -= dt;
  }
  coins = coins.filter(c => c.life > 0);
}
function drawCoins() {
  for (const c of coins) {
    ctx.save();
    ctx.translate(Math.round(c.x), Math.round(c.y));
    ctx.fillStyle = "#ffd76a";
    ctx.beginPath();
    ctx.arc(8,8,8,0,Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.fillRect(6,6,4,4);
    ctx.restore();
  }
}
function collectCoins() {
  const feet = feetRect(player);
  coins = coins.filter(c => {
    const r = {x:c.x, y:c.y, w:c.w, h:c.h};
    if (rectsOverlap(feet, r)) {
      player.gold += 1;
      setHUD();
      return false;
    }
    return true;
  });
}

/* =========================
   Zombies
   ========================= */
function spawnZombie() {
  const z = {
    x: Math.random() < .5 ? -64 : W+64,
    y: randi(64, H-128),
    w: DRAW_W, h: DRAW_H,
    dir: 0, frame: 0,
    speed: 80,
    hp: 2,
    hitCD: 0
  };
  zombies.push(z);
}
function updateZombies(dt) {
  zombieSpawnTimer -= dt;
  if (world === "snow" && zombieSpawnTimer <= 0) {
    spawnZombie();
    zombieSpawnTimer = 2 + Math.random()*1.5;
  }
  for (const z of zombies) {
    const dx = (player.x - z.x);
    const dy = (player.y - z.y);
    const d = Math.hypot(dx, dy) || 1;
    const vx = dx/d, vy = dy/d;
    tryMove(z, vx*z.speed*dt, vy*z.speed*dt);
    z.dir = Math.abs(vx) > Math.abs(vy) ? (vx<0?1:2) : (vy<0?3:0);
    z.frame = (z.frame + dt*6) % 4;
    if (z.hitCD > 0) z.hitCD -= dt;
    // damage player
    if (rectsOverlap(feetRect(z), feetRect(player)) && z.hitCD <= 0) {
      player.hearts = Math.max(0, player.hearts-1);
      setHUD();
      z.hitCD = 1.0;
      if (player.hearts <= 0) {
        // simple respawn
        player.hearts = player.maxHearts;
        player.x = (W-DRAW_W)/2;
        player.y = (H-DRAW_H)/2;
        setHUD();
      }
    }
  }
  zombies = zombies.filter(z => z.hp > 0);
}
function drawZombies() {
  for (const z of zombies) {
    const img = zombieFrames[z.dir][Math.floor(z.frame)];
    ctx.drawImage(img,0,0,BASE_W,BASE_H, Math.round(z.x), Math.round(z.y), DRAW_W, DRAW_H);
  }
}

/* =========================
   Combat (sword)
   ========================= */
function startSwing() {
  if (player.swingTime > 0) return;
  player.swingTime = 0.25; // duration
}
function updateSwing(dt) {
  if (player.swingTime > 0) {
    player.swingTime -= dt;
    // hit check in a small arc/hitbox from player's facing
    const reach = 40;
    const cx = player.x + player.w/2;
    const cy = player.y + player.h*0.7;
    let hx = cx, hy = cy;
    if (player.dir === 0) hy += reach;
    if (player.dir === 3) hy -= reach;
    if (player.dir === 1) hx -= reach;
    if (player.dir === 2) hx += reach;
    const hitbox = {x: hx-12, y: hy-12, w:24, h:24};
    for (const z of zombies) {
      if (rectsOverlap(hitbox, feetRect(z))) {
        z.hp -= 1;
        if (z.hp <= 0) {
          // drop coin exactly where zombie died
          spawnCoin(z.x + z.w/2 - 8, z.y + z.h - 24);
        }
      }
    }
  }
}

/* =========================
   Rendering helpers
   ========================= */
function drawDoor() {
  if (!door.visible) return;
  ctx.save();
  ctx.translate(Math.round(door.x), Math.round(door.y));
  ctx.fillStyle = "#5b3a1e";
  ctx.fillRect(0,0,door.w,door.h);
  ctx.fillStyle = "#8a5a2f";
  ctx.fillRect(6,6,door.w-12,door.h-12);
  // handle
  ctx.fillStyle = "#d9b66d";
  ctx.beginPath();
  ctx.arc(door.w-14, door.h/2, 4, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}

/* =========================
   Game loop
   ========================= */
let last = 0;
let running = false;

function update(dt) {
  // movement disabled during dialog
  if (!dlg.active) {
    let vx = 0, vy = 0;
    if (keys.has("arrowleft") || keys.has("a")) vx -= 1;
    if (keys.has("arrowright")|| keys.has("d")) vx += 1;
    if (keys.has("arrowup")   || keys.has("w")) vy -= 1;
    if (keys.has("arrowdown") || keys.has("s")) vy += 1;

    player.moving = (vx !== 0 || vy !== 0);
    if (player.moving) {
      const len = Math.hypot(vx, vy) || 1;
      vx /= len; vy /= len;
      if (Math.abs(vx) > Math.abs(vy)) {
        player.dir = (vx < 0) ? 1 : 2;
      } else if (Math.abs(vy) > 0) {
        player.dir = (vy < 0) ? 3 : 0;
      }
      tryMove(player, vx * player.speed * dt, vy * player.speed * dt);
    }

    if (keys.has(" ")) startSwing();
  }

  // animation frame selection (includes swing frames)
  if (player.swingTime > 0) {
    const phase = player.swingTime < 0.083 ? 2 : (player.swingTime < 0.166 ? 1 : 0);
    player.frame = 5 + phase; // 5..7 swing
  } else if (player.moving) {
    player.animTime += dt * player.animSpeed;
    const step = Math.floor(player.animTime) % 4;
    player.frame = 1 + step; // walk
  } else {
    player.animTime = 0;
    player.frame = 0; // idle
  }

  updateSwing(dt);
  updateZombies(dt);
  updateCoins(dt);

  // quest prompt near Silvio
  const nearSilvio = rectsOverlap(feetRect(player), feetRect(silvio));
  if (!questAccepted && !dlg.active && nearSilvio) {
    // show small prompt via dialog style
    openDialog([{name:"", text:'Press E to accept quest'}], ()=>{
      // immediately reopen real dialog if E pressed
    });
  }

  // handle E accept (only when not already in blocking dialog)
  if (!questAccepted && nearSilvio && keys.has("e")) {
    // close any tmp prompt
    dlg.active = false; dlg.root.style.display = "none";
    openDialog([
      {name:"Silvio", text:"Will you accept my quest my love?"},
      {name:"", text:"Press Space to continue"}
    ], ()=>{
      // MANDATORY: reveal door but DO NOT rebuild the map (prevents rerandomization)
      questAccepted = true;
      door.visible = true; // keep map static; just reveal door
    });
  }

  // door teleport
  if (door.visible && rectsOverlap(feetRect(player), {x:door.x,y:door.y,w:door.w,h:door.h})) {
    // switch to snow world
    world = "snow";
    mapSeed = 987654321; // new stable seed for snow
    buildStaticMap();
    // reposition player near bottom-left
    player.x = 80; player.y = H - 160;
    // hide door in snow world (or keep if you want)
    door.visible = false;
    zombies = [];
    coins = [];
  }
}

function render() {
  ctx.drawImage(mapBuffer, 0, 0);

  // draw Silvio (always in middle)
  const sImg = silvioFrames[silvio.dir][0];
  ctx.drawImage(sImg,0,0,BASE_W,BASE_H, Math.round(silvio.x), Math.round(silvio.y), DRAW_W, DRAW_H);

  // draw player (with sword always in hand, swing frames rotate blade)
  const img = anaFrames[player.dir][player.frame];
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img,0,0,BASE_W,BASE_H, Math.round(player.x), Math.round(player.y), DRAW_W, DRAW_H);
  ctx.restore();

  drawZombies();
  drawCoins();
  drawDoor();
}

function loop(ts) {
  if (!running) return;
  const dt = Math.min(0.033, (ts - last) / 1000 || 0);
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

/* =========================
   Start overlay
   ========================= */
const startOverlay = document.getElementById("startOverlay");
document.getElementById("startBtn").addEventListener("click", () => {
  startOverlay.style.display = "none";
  running = true;
  last = performance.now();
  requestAnimationFrame(loop);
});

/* =========================
   Init
   ========================= */
function initGame() {
  resize();
  // initial seed for grass
  mapSeed = 1337;
  world = "grass";
  buildStaticMap();
  // place entities
  player.x = (W - DRAW_W)/2;
  player.y = (H - DRAW_H)/2;
  placeSilvio();      // center
  placeDoor();        // fixed near right corner (top-right area)
  door.visible = questAccepted; // usually false on first load
  setHUD();
}
initGame();
</script>
</body>
</html>
