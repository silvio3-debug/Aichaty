<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Adventure</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000;
  }
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 5;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
  }
  #startBtn:active { transform: translateY(1px); }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="startOverlay">
  <div id="title">Pixel Adventure</div>
  <button id="startBtn">Start Game</button>
</div>

<script>
/* =========================
   Basic engine + sizing
   ========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;

function resize() {
  W = canvas.width  = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  ctx.imageSmoothingEnabled = false;
  buildStaticMap();
}
window.addEventListener("resize", resize);

/* =========================
   Input handling
   ========================= */
const keys = new Set();
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"];
  if (moveKeys.includes(k)) e.preventDefault();
  keys.add(k);
});
window.addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

/* =========================
   Random helpers
   ========================= */
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

/* =========================
   Map (static, full screen)
   ========================= */
let mapBuffer, mapCtx;
let solidRects = [];

function buildStaticMap() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  mapCtx.fillStyle = "#6ac36a";
  mapCtx.fillRect(0,0,W,H);

  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = Math.random();
      if (v < 0.18) {
        mapCtx.fillStyle = "#64bb64";
        mapCtx.fillRect(x, y, cell, cell);
      } else if (v < 0.28) {
        mapCtx.fillStyle = "#71cd71";
        mapCtx.fillRect(x, y, cell, cell);
      }
    }
  }

  const flowerCount = Math.floor((W*H) / 12000);
  for (let i = 0; i < flowerCount; i++) {
    const x = randi(8, W-8);
    const y = randi(8, H-8);
    const type = randi(0,3);
    if (type === 0) mapCtx.fillStyle = "#ffe6f2";
    if (type === 1) mapCtx.fillStyle = "#fff8a6";
    if (type === 2) mapCtx.fillStyle = "#b0e3ff";
    mapCtx.fillRect(x, y, 3, 3);
    mapCtx.fillRect(x+2, y+1, 2, 2);
    mapCtx.fillRect(x-1, y+1, 2, 2);
    mapCtx.fillStyle = "#2f7b2f";
    mapCtx.fillRect(x+1, y+3, 1, 3);
  }

  solidRects = [];
  const treeCount = Math.floor((W*H) / 50000);
  for (let i = 0; i < treeCount; i++) {
    const x = randi(60, W-60);
    const y = randi(60, H-60);
    drawTree(mapCtx, x, y);
  }
}

function drawTree(g, x, y) {
  g.fillStyle = "#2e8b57";
  for (let r = 26; r >= 18; r -= 4) {
    g.beginPath();
    g.arc(x, y, r, 0, Math.PI*2);
    g.fill();
  }
  g.fillStyle = "#3da86e";
  g.beginPath();
  g.arc(x-8, y-8, 10, 0, Math.PI*2);
  g.fill();

  const trunkW = 14, trunkH = 26;
  const tx = x - trunkW/2, ty = y + 10;
  g.fillStyle = "#8b5a2b";
  g.fillRect(tx, ty, trunkW, trunkH);
  g.fillStyle = "#a06c38";
  g.fillRect(tx+4, ty+2, 4, trunkH-4);

  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}

/* =========================
   Character sprite builder
   ========================= */
const BASE_W = 16, BASE_H = 24;
const SCALE = 4;
const DRAW_W = BASE_W * SCALE;
const DRAW_H = BASE_H * SCALE;

function makeFrame(drawFn) {
  const c = document.createElement("canvas");
  c.width = BASE_W; c.height = BASE_H;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;
  drawFn(g);
  return c;
}

function p(g, x, y, color) {
  g.fillStyle = color;
  g.fillRect(x, y, 1, 1);
}

const skin = "#f0c8a8";
const hair = "#5a3a21";
const hairHL = "#6b482b";
const eyes = "#2a2a2a";
const outfitMain = "#1f8a3c";
const outfitShadow = "#166a2e";
const boots = "#4b3928";
const belt = "#2e2e2e";

function drawCharacter(g, dir, frameIndex) {
  g.clearRect(0,0,BASE_W,BASE_H);

  const walkFrames = [
    {legL: -2, legR: 2, armL: 2, armR: -2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 2,  legR: -2, armL: -2, armR: 2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0},
    {headY:-1, bodyY:0, arm:-1},
    {headY:-1, bodyY:0, arm:1},
    {headY:0, bodyY:-1, arm:0},
  ];

  const isIdle = (frameIndex === 0);
  let headY=0, bodyY=0, armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;

  if (isIdle) {
    const ip = idlePose[dir];
    headY = ip.headY; bodyY = ip.bodyY;
    armSwingL = ip.arm; armSwingR = -ip.arm;
  } else {
    const w = walkFrames[(frameIndex-1) % 4];
    armSwingL = w.armL; armSwingR = w.armR;
    legSwingL = w.legL; legSwingR = w.legR;
  }

  const headX = 3, headTop = 2 + headY;
  const bodyTop = 12 + bodyY;
  const bodyX = 3;

  function drawHairBack() {
    const col = hair;
    for (let x=2; x<=13; x++) p(g,x,headTop, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+1, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+2, col);
    for (let x=1; x<=14; x++) p(g,x,headTop+3, col);
    for (let x=2; x<=13; x++) p(g,x,headTop+4, col);
    p(g,2, headTop+5, col); p(g,13, headTop+5, col);
  }

  function drawHeadFront() {
    for (let y=0; y<8; y++) {
      for (let x=0; x<8; x++) {
        p(g, headX+x, headTop+1+y, skin);
      }
    }
    for (let x=headX+1; x<=headX+6; x++) p(g, x, headTop+9, skin);

    if (dir === 0) {
      p(g, headX, headTop+1, hairHL);
      p(g, headX+7, headTop+1, hairHL);
      p(g, headX+2, headTop+1, hair);
      p(g, headX+5, headTop+1, hair);
    } else if (dir === 1) {
      for (let y=0; y<6; y++) p(g, headX, headTop+2+y, hairHL);
      p(g, headX+1, headTop+2, hairHL);
    } else if (dir === 2) {
      for (let y=0; y<6; y++) p(g, headX+7, headTop+2+y, hairHL);
      p(g, headX+6, headTop+2, hairHL);
    } else {
      for (let x=headX; x<headX+8; x++) p(g, x, headTop+1, hair);
    }
  }

  function drawFace() {
    if (dir === 3) {
      p(g, headX+2, headTop+3, eyes);
      p(g, headX+5, headTop+3, eyes);
    } else {
      p(g, headX+2, headTop+4, eyes);
      p(g, headX+5, headTop+4, eyes);
      p(g, headX+3, headTop+6, "#aa6a6a");
    }
    // round glasses for all directions
    const glassColor = "#444";
    p(g, headX+1, headTop+4, glassColor);
    p(g, headX+6, headTop+4, glassColor);
    p(g, headX+1, headTop+5, glassColor);
    p(g, headX+6, headTop+5, glassColor);
  }

  function drawTorso() {
    for (let y=0; y<6; y++) {
      for (let x=0; x<8; x++) {
        const col = (y >= 2) ? outfitShadow : outfitMain;
        p(g, bodyX+x, bodyTop+y, col);
      }
    }
    for (let x=bodyX; x<bodyX+8; x++) p(g, x, bodyTop+6, belt);
  }

  function drawArms() {
    const leftX  = bodyX-1, rightX = bodyX+8;
    const armTop = bodyTop+1;
    p(g, leftX, armTop, outfitMain);
    p(g, rightX, armTop, outfitMain);
    let ly = armTop + Math.round(armSwingL/2);
    let ry = armTop + Math.round(armSwingR/2);
    p(g, leftX, ly+1, skin);
    p(g, leftX, ly+2, skin);
    p(g, rightX, ry+1, skin);
    p(g, rightX, ry+2, skin);
  }

  function drawLegsAndBoots() {
    const legTop = bodyTop+7;
    const mid = bodyX+3;
    const lX = mid-2, rX = mid+2;
    const lOffset = Math.round(legSwingL/2);
    const rOffset = Math.round(legSwingR/2);
    p(g, lX, legTop + lOffset, outfitShadow);
    p(g, lX, legTop+1 + lOffset, outfitShadow);
    p(g, rX, legTop + rOffset, outfitShadow);
    p(g, rX, legTop+1 + rOffset, outfitShadow);
    p(g, lX, legTop+2 + lOffset, boots);
    p(g, lX, legTop+3 + lOffset, boots);
    p(g, rX, legTop+2 + rOffset, boots);
    p(g, rX, legTop+3 + rOffset, boots);
    if (dir === 1) {
      p(g, lX-1, legTop+3 + lOffset, boots);
    } else if (dir === 2) {
      p(g, rX+1, legTop+3 + rOffset, boots);
    } else {
      p(g, lX, legTop+4 + lOffset, boots);
      p(g, rX, legTop+4 + rOffset, boots);
    }
  }

  drawHairBack();
  drawHeadFront();
  drawFace();
  drawTorso();
  drawArms();
  drawLegsAndBoots();

  if (dir === 3) {
    p(g, bodyX+3, bodyTop, "#25a048");
  }
}

const frames = [[],[],[],[]];
for (let dir = 0; dir < 4; dir++) {
  for (let f = 0; f < 5; f++) {
    frames[dir][f] = makeFrame((g) => drawCharacter(g, dir, f));
  }
}

/* =========================
   Player entity
   ========================= */
const player = {
  x: 120, y: 120,
  w: DRAW_W, h: DRAW_H,
  speed: 180,
  dir: 0,
  frame: 0,
  animTime: 0,
  animSpeed: 9,
  moving: false,
};

function rectsOverlap(a, b) {
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}

function tryMove(dt, dx, dy) {
  const next = { x: player.x + dx, y: player.y + dy, w: player.w, h: player.h };
  const feet = { x: next.x + player.w*0.25, y: next.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };

  if (feet.x < 0) next.x = player.x; 
  if (feet.y < 0) next.y = player.y; 
  if (feet.x + feet.w > W) next.x = player.x; 
  if (feet.y + feet.h > H) next.y = player.y;

  for (const s of solidRects) {
    if (rectsOverlap(feet, s)) {
      const testX = { x: player.x + dx, y: player.y, w: player.w, h: player.h };
      const feetX = { x: testX.x + player.w*0.25, y: testX.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!rectsOverlap(feetX, s)) {
        player.x += dx;
        return;
      }
      const testY = { x: player.x, y: player.y + dy, w: player.w, h: player.h };
      const feetY = { x: testY.x + player.w*0.25, y: testY.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!rectsOverlap(feetY, s)) {
        player.y += dy;
        return;
      }
      return;
    }
  }
  player.x = next.x;
  player.y = next.y;
}

/* =========================
   Game loop
   ========================= */
let last = 0;
let running = false;

function update(dt) {
  let vx = 0, vy = 0;
  if (keys.has("arrowleft") || keys.has("a")) vx -= 1;
  if (keys.has("arrowright")|| keys.has("d")) vx += 1;
  if (keys.has("arrowup")   || keys.has("w")) vy -= 1;
  if (keys.has("arrowdown") || keys.has("s")) vy += 1;

  player.moving = (vx !== 0 || vy !== 0);
  if (player.moving) {
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;

    if (Math.abs(vx) > Math.abs(vy)) {
      player.dir = (vx < 0) ? 1 : 2;
    } else if (Math.abs(vy) > 0) {
      player.dir = (vy < 0) ? 3 : 0;
    }

    const dx = vx * player.speed * dt;
    const dy = vy * player.speed * dt;
    tryMove(dt, dx, dy);
  }

  if (player.moving) {
    player.animTime += dt * player.animSpeed;
    const step = Math.floor(player.animTime) % 4;
    player.frame = 1 + step;
  } else {
    player.animTime = 0;
    player.frame = 0;
  }
}

function render() {
  ctx.drawImage(mapBuffer, 0, 0);
  const img = frames[player.dir][player.frame];
  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(
    img,
    0,0, BASE_W, BASE_H,
    Math.round(player.x), Math.round(player.y),
    DRAW_W, DRAW_H
  );
  ctx.restore();
  ctx.fillStyle = "white";
  ctx.font = "20px Arial";
  ctx.textAlign = "center";
  ctx.fillText("ana", Math.round(player.x + DRAW_W/2), Math.round(player.y) - 10);
}

function loop(ts) {
  if (!running) return;
  const dt = Math.min(0.033, (ts - last) / 1000 || 0);
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

/* =========================
   Start overlay
   ========================= */
const startOverlay = document.getElementById("startOverlay");
document.getElementById("startBtn").addEventListener("click", () => {
  startOverlay.style.display = "none";
  running = true;
  last = performance.now();
  requestAnimationFrame(loop);
});

/* =========================
   Init
   ========================= */
resize();
player.x = (W - DRAW_W)/2;
player.y = (H - DRAW_H)/2;

</script>
</body>
</html>
