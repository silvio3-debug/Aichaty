<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Adventure</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    overflow: hidden;
    font-family: system-ui, sans-serif;
  }
  #game {
    display: block;
    width: 100vw;
    height: 100vh;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background: #000; /* will be covered by map render */
  }
  /* Start overlay */
  #startOverlay {
    position: fixed;
    inset: 0;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    flex-direction:column;
    z-index: 5;
  }
  #title {
    color:#fff;
    font-size: clamp(18px, 3vw, 32px);
    margin-bottom: 18px;
    letter-spacing: 1px;
  }
  #startBtn {
    background:#fff;
    color:#000;
    border: none;
    padding: 12px 18px;
    font-size: clamp(14px, 2.2vw, 18px);
    border-radius: 8px;
    cursor: pointer;
  }
  #startBtn:active { transform: translateY(1px); }

  /* Dialog box */
  #dialog {
    position: fixed;
    left: 50%;
    bottom: 5vh;
    transform: translateX(-50%);
    min-width: min(90vw, 900px);
    max-width: 90vw;
    background: rgba(0,0,0,0.85);
    color: #fff;
    border: 2px solid #fff;
    border-radius: 10px;
    padding: 14px 16px;
    font-size: clamp(14px, 2.2vw, 18px);
    line-height: 1.4;
    z-index: 6;
    display: none;
  }
  #prompt {
    position: fixed;
    left: 50%;
    bottom: 8vh;
    transform: translateX(-50%);
    color:#fff;
    font-size: clamp(12px, 2vw, 16px);
    background: rgba(0,0,0,0.6);
    padding: 6px 10px;
    border-radius: 8px;
    z-index: 4;
    display:none;
  }

  /* Fade overlay for transitions */
  #fade {
    position: fixed;
    inset: 0;
    background: #000;
    opacity: 0;
    pointer-events: none;
    z-index: 7;
  }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="startOverlay">
  <div id="title">Pixel Adventure</div>
  <button id="startBtn">Start Game</button>
</div>

<div id="dialog"></div>
<div id="prompt"></div>
<div id="fade"></div>

<script>
/* =========================
   Basic engine + sizing
   ========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });
let W = 0, H = 0;

function resize() {
  W = canvas.width  = Math.floor(window.innerWidth);
  H = canvas.height = Math.floor(window.innerHeight);
  // Keep pixels crisp when scaling
  ctx.imageSmoothingEnabled = false;
  // Rebuild map buffer to match new size for current map
  buildStaticMap();
  // Reposition NPC/door relative to screen (keeps “top-right area”)
  positionSilvioAndDoor();
}
window.addEventListener("resize", resize);

/* =========================
   Input handling
   ========================= */
const keys = new Set();
window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  const moveKeys = ["arrowup","arrowdown","arrowleft","arrowright","w","a","s","d"," "];
  if (moveKeys.includes(k) || k === "e") e.preventDefault();
  keys.add(k);

  // Interaction keys (handled on keydown to feel immediate)
  if (k === "e") tryStartQuest();
  if (k === " " || k === "spacebar") advanceDialog();
});
window.addEventListener("keyup", (e) => {
  keys.delete(e.key.toLowerCase());
});

/* =========================
   Random helpers
   ========================= */
function rand(min, max) { return Math.random() * (max - min) + min; }
function randi(min, max) { return Math.floor(rand(min, max)); }

/* =========================
   MAPS: Grass & Snow (static, full screen)
   ========================= */
let mapBuffer, mapCtx;
let solidRects = []; // collision solids (trunks/rocks)
let currentMap = "grass"; // "grass" | "snow"

function buildStaticMap() {
  if (currentMap === "grass") buildGrass();
  else buildSnow();
}

function buildGrass() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  // Base grass
  mapCtx.fillStyle = "#6ac36a"; // main grass
  mapCtx.fillRect(0,0,W,H);

  // Subtle grass noise tiles
  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = Math.random();
      if (v < 0.18) {
        mapCtx.fillStyle = "#64bb64";
        mapCtx.fillRect(x, y, cell, cell);
      } else if (v < 0.28) {
        mapCtx.fillStyle = "#71cd71";
        mapCtx.fillRect(x, y, cell, cell);
      }
    }
  }

  // Sprinkle flowers
  const flowerCount = Math.floor((W*H) / 12000);
  for (let i = 0; i < flowerCount; i++) {
    const x = randi(8, W-8);
    const y = randi(8, H-8);
    const type = randi(0,3);
    if (type === 0) mapCtx.fillStyle = "#ffe6f2"; // pink
    if (type === 1) mapCtx.fillStyle = "#fff8a6"; // pale yellow
    if (type === 2) mapCtx.fillStyle = "#b0e3ff"; // sky
    mapCtx.fillRect(x, y, 3, 3);
    mapCtx.fillRect(x+2, y+1, 2, 2);
    mapCtx.fillRect(x-1, y+1, 2, 2);
    // stem
    mapCtx.fillStyle = "#2f7b2f";
    mapCtx.fillRect(x+1, y+3, 1, 3);
  }

  // Trees (foliage + trunk; trunk is solid)
  solidRects = [];
  const treeCount = Math.floor((W*H) / 50000);
  for (let i = 0; i < treeCount; i++) {
    const x = randi(60, W-60);
    const y = randi(60, H-60);
    drawTree(mapCtx, x, y);
  }
}

function buildSnow() {
  mapBuffer = document.createElement("canvas");
  mapBuffer.width = W;
  mapBuffer.height = H;
  mapCtx = mapBuffer.getContext("2d");
  mapCtx.imageSmoothingEnabled = false;

  // Base snow
  mapCtx.fillStyle = "#f5f9ff"; // snow white
  mapCtx.fillRect(0,0,W,H);

  // Subtle snow noise
  const cell = 8;
  for (let y = 0; y < H; y += cell) {
    for (let x = 0; x < W; x += cell) {
      const v = Math.random();
      if (v < 0.18) {
        mapCtx.fillStyle = "#e9f2ff";
        mapCtx.fillRect(x, y, cell, cell);
      } else if (v < 0.28) {
        mapCtx.fillStyle = "#eef6ff";
        mapCtx.fillRect(x, y, cell, cell);
      }
    }
  }

  // Snowy trees
  solidRects = [];
  const treeCount = Math.floor((W*H) / 60000);
  for (let i = 0; i < treeCount; i++) {
    const x = randi(60, W-60);
    const y = randi(60, H-60);
    drawSnowTree(mapCtx, x, y);
  }

  // Occasional ice patch (non-solid cosmetic)
  const iceCount = Math.floor((W*H) / 160000);
  for (let i = 0; i < iceCount; i++) {
    const x = randi(40, W-80), y = randi(40, H-80);
    mapCtx.fillStyle = "rgba(150,200,255,0.4)";
    mapCtx.beginPath();
    mapCtx.ellipse(x, y, 30, 18, 0, 0, Math.PI*2);
    mapCtx.fill();
  }
}

function drawTree(g, x, y) {
  // Foliage: layered circles
  g.fillStyle = "#2e8b57";
  for (let r = 26; r >= 18; r -= 4) {
    g.beginPath();
    g.arc(x, y, r, 0, Math.PI*2);
    g.fill();
  }
  // Highlights
  g.fillStyle = "#3da86e";
  g.beginPath();
  g.arc(x-8, y-8, 10, 0, Math.PI*2);
  g.fill();

  // Trunk (solid rect)
  const trunkW = 14, trunkH = 26;
  const tx = x - trunkW/2, ty = y + 10;
  g.fillStyle = "#8b5a2b";
  g.fillRect(tx, ty, trunkW, trunkH);
  g.fillStyle = "#a06c38";
  g.fillRect(tx+4, ty+2, 4, trunkH-4);

  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}

function drawSnowTree(g, x, y) {
  // Snowy cone-ish foliage
  g.fillStyle = "#cfe9ff";
  for (let r = 24; r >= 14; r -= 5) {
    g.beginPath();
    g.arc(x, y, r, 0, Math.PI*2);
    g.fill();
  }
  // snow cap
  g.fillStyle = "#ffffff";
  g.beginPath();
  g.arc(x-6, y-10, 8, 0, Math.PI*2);
  g.fill();

  // Trunk (solid)
  const trunkW = 12, trunkH = 24;
  const tx = x - trunkW/2, ty = y + 10;
  g.fillStyle = "#7b4a25";
  g.fillRect(tx, ty, trunkW, trunkH);

  solidRects.push({x: tx, y: ty, w: trunkW, h: trunkH});
}

/* =========================
   Character sprite builder (ANA)
   Terraria-style 8-bit, 16x24 px base, scaled x4
   Directions: 0=down,1=left,2=right,3=up
   Frames: idle(0), walk1(1), walk2(2), walk3(3), walk4(4)
   ========================= */
const BASE_W = 16, BASE_H = 24;
const SCALE = 4; // 16x24 -> 64x96 on screen
const DRAW_W = BASE_W * SCALE;
const DRAW_H = BASE_H * SCALE;

function makeFrame(drawFn, w=BASE_W, h=BASE_H) {
  const c = document.createElement("canvas");
  c.width = w; c.height = h;
  const g = c.getContext("2d");
  g.imageSmoothingEnabled = false;
  drawFn(g);
  return c;
}
function p(g, x, y, color) { g.fillStyle = color; g.fillRect(x, y, 1, 1); }

// Palette (Ana)
const skin = "#f0c8a8";
const hair = "#5a3a21";
const hairHL = "#6b482b";
const eyes = "#2a2a2a";
const outfitMain = "#1f8a3c";  // green outfit
const outfitShadow = "#166a2e";
const boots = "#4b3928";
const belt = "#2e2e2e";

function drawCharacterAna(g, dir, frameIndex) {
  g.clearRect(0,0,BASE_W,BASE_H);
  const walkFrames = [
    {legL: -2, legR: 2, armL: 2, armR: -2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
    {legL: 2,  legR: -2, armL: -2, armR: 2},
    {legL: 0,  legR: 0, armL: 0, armR: 0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0},  // down
    {headY:-1, bodyY:0, arm:-1},// left
    {headY:-1, bodyY:0, arm:1}, // right
    {headY:0, bodyY:-1, arm:0}, // up
  ];
  const isIdle = (frameIndex === 0);
  let headY=0, bodyY=0, armSwingL=0, armSwingR=0, legSwingL=0, legSwingR=0;
  if (isIdle) {
    const ip = idlePose[dir]; headY=ip.headY; bodyY=ip.bodyY; armSwingL=ip.arm; armSwingR=-ip.arm;
  } else {
    const w = walkFrames[(frameIndex-1)%4];
    armSwingL=w.armL; armSwingR=w.armR; legSwingL=w.legL; legSwingR=w.legR;
  }

  const headX=3, headTop=2+headY; const bodyTop=12+bodyY; const bodyX=3;

  function hairBack(){
    const col = hair;
    for (let x=2; x<=13; x++) p(g,x,headTop,col);
    for (let x=1; x<=14; x++) p(g,x,headTop+1,col);
    for (let x=1; x<=14; x++) p(g,x,headTop+2,col);
    for (let x=1; x<=14; x++) p(g,x,headTop+3,col);
    for (let x=2; x<=13; x++) p(g,x,headTop+4,col);
    p(g,2,headTop+5,col); p(g,13,headTop+5,col);
  }
  function headFace(){
    for (let y=0; y<8; y++) for (let x=0; x<8; x++) p(g, headX+x, headTop+1+y, skin);
    for (let x=headX+1; x<=headX+6; x++) p(g, x, headTop+9, skin);
    if (dir===0){ p(g, headX, headTop+1, hairHL); p(g, headX+7, headTop+1, hairHL); p(g, headX+2, headTop+1, hair); p(g, headX+5, headTop+1, hair); }
    else if (dir===1){ for(let y=0;y<6;y++) p(g, headX, headTop+2+y, hairHL); p(g, headX+1, headTop+2, hairHL); }
    else if (dir===2){ for(let y=0;y<6;y++) p(g, headX+7, headTop+2+y, hairHL); p(g, headX+6, headTop+2, hairHL); }
    else { for (let x=headX; x<headX+8; x++) p(g, x, headTop+1, hair); }

    // Eyes + mouth
    if (dir===3){ p(g, headX+2, headTop+3, eyes); p(g, headX+5, headTop+3, eyes); }
    else { p(g, headX+2, headTop+4, eyes); p(g, headX+5, headTop+4, eyes); p(g, headX+3, headTop+6, "#aa6a6a"); }

    // Round glasses (simple pixel rims) except when facing up (keeps it readable)
    if (dir!==3){
      // left lens rim
      p(g, headX+1, headTop+4, "#000"); p(g, headX+3, headTop+4, "#000");
      p(g, headX+2, headTop+3, "#000"); p(g, headX+2, headTop+5, "#000");
      // right lens rim
      p(g, headX+4, headTop+4, "#000"); p(g, headX+6, headTop+4, "#000");
      p(g, headX+5, headTop+3, "#000"); p(g, headX+5, headTop+5, "#000");
      // bridge
      p(g, headX+4, headTop+4, "#000");
    }
  }
  function torso(){
    for (let y=0; y<6; y++) for (let x=0; x<8; x++) p(g, bodyX+x, bodyTop+y, (y>=2)?outfitShadow:outfitMain);
    for (let x=bodyX; x<bodyX+8; x++) p(g, x, bodyTop+6, belt);
  }
  function arms(){
    const leftX=bodyX-1, rightX=bodyX+8, armTop=bodyTop+1;
    p(g,leftX,armTop,outfitMain); p(g,rightX,armTop,outfitMain);
    let ly=armTop+Math.round(armSwingL/2), ry=armTop+Math.round(armSwingR/2);
    p(g,leftX,ly+1,skin); p(g,leftX,ly+2,skin); p(g,rightX,ry+1,skin); p(g,rightX,ry+2,skin);
  }
  function legs(){
    const legTop=bodyTop+7, mid=bodyX+3, lX=mid-2, rX=mid+2;
    const lOff=Math.round(legSwingL/2), rOff=Math.round(legSwingR/2);
    p(g,lX,legTop+lOff,outfitShadow); p(g,lX,legTop+1+lOff,outfitShadow);
    p(g,rX,legTop+rOff,outfitShadow); p(g,rX,legTop+1+rOff,outfitShadow);
    p(g,lX,legTop+2+lOff,boots); p(g,lX,legTop+3+lOff,boots);
    p(g,rX,legTop+2+rOff,boots); p(g,rX,legTop+3+rOff,boots);
    if (dir===1) p(g,lX-1,legTop+3+lOff,boots);
    else if (dir===2) p(g,rX+1,legTop+3+rOff,boots);
    else { p(g,lX,legTop+4+lOff,boots); p(g,rX,legTop+4+rOff,boots); }
  }

  hairBack(); headFace(); torso(); arms(); legs();
  if (dir===3) p(g, bodyX+3, bodyTop, "#25a048");
}

const frames = [[],[],[],[]];
for (let dir = 0; dir < 4; dir++) for (let f = 0; f < 5; f++)
  frames[dir][f] = makeFrame((g) => drawCharacterAna(g, dir, f));

/* =========================
   NPC Silvio (taller, muscular-ish)
   Separate sprite size: 16x28, scale x4 => 64x112
   Outfit = different color
   ========================= */
const BASE_W_S = 16, BASE_H_S = 28, SCALE_S = 4;
const DRAW_W_S = BASE_W_S * SCALE_S, DRAW_H_S = BASE_H_S * SCALE_S;

const outfitMainS = "#2e4fa5";   // deep blue
const outfitShadowS = "#223e82";
const bootsS = "#3f3024";
const beltS = "#202020";

function drawSilvio(g, dir, frameIndex) {
  g.clearRect(0,0,BASE_W_S,BASE_H_S);
  const walkFrames = [
    {legL:-2, legR:2, armL:2, armR:-2},
    {legL:0,  legR:0, armL:0, armR:0},
    {legL:2,  legR:-2, armL:-2, armR:2},
    {legL:0,  legR:0, armL:0, armR:0},
  ];
  const idlePose = [
    {headY:0, bodyY:0, arm:0}, {headY:-1, bodyY:0, arm:-1},
    {headY:-1, bodyY:0, arm:1}, {headY:0, bodyY:-1, arm:0},
  ];
  const isIdle = (frameIndex===0);
  let headY=0, bodyY=0, armL=0, armR=0, legL=0, legR=0;
  if (isIdle){ const ip=idlePose[dir]; headY=ip.headY; bodyY=ip.bodyY; armL=ip.arm; armR=-ip.arm; }
  else { const w=walkFrames[(frameIndex-1)%4]; armL=w.armL; armR=w.armR; legL=w.legL; legR=w.legR; }

  const headX=3, headTop=2+headY; const bodyTop=12+bodyY; const bodyX=2;

  // hair back
  for (let x=2; x<=13; x++) p(g,x,headTop, hair);
  for (let x=1; x<=14; x++) p(g,x,headTop+1, hair);
  for (let x=1; x<=14; x++) p(g,x,headTop+2, hair);
  for (let x=1; x<=14; x++) p(g,x,headTop+3, hair);
  for (let x=2; x<=13; x++) p(g,x,headTop+4, hair);
  p(g,2,headTop+5,hair); p(g,13,headTop+5,hair);

  // head + face (same as Ana)
  for (let y=0; y<8; y++) for (let x=0; x<8; x++) p(g, headX+x, headTop+1+y, skin);
  for (let x=headX+1; x<=headX+6; x++) p(g, x, headTop+9, skin);
  if (dir===0){ p(g, headX, headTop+1, hairHL); p(g, headX+7, headTop+1, hairHL); }
  else if (dir===1){ for(let y=0;y<6;y++) p(g, headX, headTop+2+y, hairHL); }
  else if (dir===2){ for(let y=0;y<6;y++) p(g, headX+7, headTop+2+y, hairHL); }
  else { for (let x=headX; x<headX+8; x++) p(g, x, headTop+1, hair); }
  if (dir===3){ p(g, headX+2, headTop+3, eyes); p(g, headX+5, headTop+3, eyes); }
  else { p(g, headX+2, headTop+4, eyes); p(g, headX+5, headTop+4, eyes); p(g, headX+3, headTop+6, "#8f5a5a"); }

  // torso (wider = “muscular-ish”)
  for (let y=0; y<8; y++) for (let x=0; x<10; x++)
    p(g, bodyX+x, bodyTop+y, (y>=3)?outfitShadowS:outfitMainS);
  for (let x=bodyX; x<bodyX+10; x++) p(g, x, bodyTop+8, beltS);

  // arms a bit thicker
  const leftX=bodyX-1, rightX=bodyX+10, armTop=bodyTop+2;
  p(g,leftX,armTop,outfitMainS); p(g,leftX,armTop+1,outfitMainS);
  p(g,rightX,armTop,outfitMainS); p(g,rightX,armTop+1,outfitMainS);
  let ly=armTop+Math.round(armL/2), ry=armTop+Math.round(armR/2);
  p(g,leftX,ly+2,skin); p(g,leftX,ly+3,skin);
  p(g,rightX,ry+2,skin); p(g,rightX,ry+3,skin);

  // legs (longer => taller)
  const legTop=bodyTop+9, mid=bodyX+4, lX=mid-2, rX=mid+3;
  const lOff=Math.round(legL/2), rOff=Math.round(legR/2);
  p(g,lX,legTop+lOff,outfitShadowS); p(g,lX,legTop+1+lOff,outfitShadowS); p(g,lX,legTop+2+lOff,outfitShadowS);
  p(g,rX,legTop+rOff,outfitShadowS); p(g,rX,legTop+1+rOff,outfitShadowS); p(g,rX,legTop+2+rOff,outfitShadowS);
  p(g,lX,legTop+3+lOff,bootsS); p(g,lX,legTop+4+lOff,bootsS);
  p(g,rX,legTop+3+rOff,bootsS); p(g,rX,legTop+4+rOff,bootsS);
}

const framesS = [[],[],[],[]];
for (let dir = 0; dir < 4; dir++) for (let f = 0; f < 5; f++)
  framesS[dir][f] = makeFrame((g) => drawSilvio(g, dir, f), BASE_W_S, BASE_H_S);

/* =========================
   Entities
   ========================= */
const player = {
  x: 120, y: 120,
  w: DRAW_W, h: DRAW_H,
  speed: 180, // px/sec
  dir: 0, // 0 down,1 left,2 right,3 up
  frame: 0,
  animTime: 0,
  animSpeed: 9, // frames per second for walking
  moving: false,
  name: "Ana",
};

const silvio = {
  x: 0, y: 0,
  w: DRAW_W_S, h: DRAW_H_S,
  dir: 0,
  frame: 0,
  animTime: 0,
  animSpeed: 6,
  name: "Silvio",
};

const door = { x: 0, y: 0, w: 40, h: 80 }; // will be positioned near Silvio

function positionSilvioAndDoor() {
  // Place Silvio near top-right area (not exact corner)
  silvio.x = Math.max(40, W - 220);
  silvio.y = Math.max(60, 120);

  // Place door a bit left of Silvio
  door.x = silvio.x - 70;
  door.y = silvio.y + silvio.h - door.h - 10;
}

/* =========================
   Quest & Dialog
   ========================= */
let questAccepted = false;
let dialogActive = false;
let dialogQueue = [];
const dialogBox = document.getElementById("dialog");
const promptBox = document.getElementById("prompt");

function showPrompt(text) {
  promptBox.textContent = text;
  promptBox.style.display = "block";
}
function hidePrompt() {
  promptBox.style.display = "none";
}

function openDialog(lines) {
  dialogQueue = Array.isArray(lines) ? lines.slice() : [String(lines)];
  dialogActive = true;
  player.moving = false; // lock movement
  updateDialogBox();
}
function updateDialogBox() {
  if (dialogQueue.length === 0) {
    dialogActive = false;
    dialogBox.style.display = "none";
    return;
  }
  dialogBox.innerHTML = dialogQueue[0] + `<div style="opacity:.8;margin-top:8px;font-size:.9em;">press SPACE to continue</div>`;
  dialogBox.style.display = "block";
}
function advanceDialog() {
  if (!dialogActive) return;
  dialogQueue.shift();
  if (dialogQueue.length === 0) {
    dialogActive = false;
    dialogBox.style.display = "none";
    // If this dialog was Silvio's question, mark quest accepted
    if (!questAccepted) questAccepted = true;
  } else {
    updateDialogBox();
  }
}

function tryStartQuest() {
  if (dialogActive || questAccepted) return;
  // Only if near Silvio
  const near = distanceCenter(player, silvio) < 110;
  if (near) {
    hidePrompt();
    openDialog([`“Will you accept my quest my love?”`]);
  }
}

/* =========================
   Collision & helpers
   ========================= */
function rectsOverlap(a, b) {
  return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h);
}
function feetRect(ent) {
  return {
    x: ent.x + ent.w*0.25,
    y: ent.y + ent.h*0.65,
    w: ent.w*0.5,
    h: ent.h*0.3
  };
}
function distanceCenter(a, b) {
  const ax = a.x + a.w/2, ay = a.y + a.h/2;
  const bx = b.x + b.w/2, by = b.y + b.h/2;
  const dx = ax - bx, dy = ay - by;
  return Math.hypot(dx, dy);
}

function tryMove(dt, dx, dy) {
  const next = { x: player.x + dx, y: player.y + dy, w: player.w, h: player.h };
  const feet = { x: next.x + player.w*0.25, y: next.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };

  // screen bounds
  if (feet.x < 0) next.x = player.x; 
  if (feet.y < 0) next.y = player.y; 
  if (feet.x + feet.w > W) next.x = player.x; 
  if (feet.y + feet.h > H) next.y = player.y;

  // solids
  for (const s of solidRects) {
    if (rectsOverlap(feet, s)) {
      const testX = { x: player.x + dx, y: player.y, w: player.w, h: player.h };
      const feetX = { x: testX.x + player.w*0.25, y: testX.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!solidRects.some(ss => rectsOverlap(feetX, ss))) { player.x += dx; return; }
      const testY = { x: player.x, y: player.y + dy, w: player.w, h: player.h };
      const feetY = { x: testY.x + player.w*0.25, y: testY.y + player.h*0.65, w: player.w*0.5, h: player.h*0.3 };
      if (!solidRects.some(ss => rectsOverlap(feetY, ss))) { player.y += dy; return; }
      return;
    }
  }

  player.x = next.x;
  player.y = next.y;
}

/* =========================
   Door / Teleport (requires quest)
   ========================= */
const fadeEl = document.getElementById("fade");
let fading = false;

function fadeToBlackThen(cb) {
  if (fading) return;
  fading = true;
  let t = 0;
  const dur = 450; // ms
  function step(ts0){
    t += 16.67;
    const k = Math.min(1, t/dur);
    fadeEl.style.opacity = String(k);
    if (k < 1) requestAnimationFrame(step);
    else setTimeout(() => {
      cb && cb();
      // fade back in
      let t2=0;
      function step2(){
        t2 += 16.67;
        const k2 = Math.max(0, 1 - t2/dur);
        fadeEl.style.opacity = String(k2);
        if (k2 > 0) requestAnimationFrame(step2);
        else { fading = false; }
      }
      requestAnimationFrame(step2);
    }, 50);
  }
  requestAnimationFrame(step);
}

function tryDoorTeleport() {
  const feet = feetRect(player);
  const doorRect = { x: door.x, y: door.y, w: door.w, h: door.h };
  if (rectsOverlap(feet, doorRect)) {
    if (!questAccepted) {
      showPrompt("You must accept Silvio's quest first.");
      setTimeout(hidePrompt, 1200);
      return;
    }
    // Teleport to snow map
    fadeToBlackThen(() => {
      currentMap = (currentMap === "grass") ? "snow" : "grass";
      buildStaticMap();
      // place player near spawn (center)
      player.x = (W - DRAW_W)/2;
      player.y = (H - DRAW_H)/2;
      // Silvio & door only on grass map
      positionSilvioAndDoor();
    });
  }
}

/* =========================
   Game loop
   ========================= */
let last = 0;
let running = false;

function update(dt) {
  // movement disabled during dialog
  let vx = 0, vy = 0;
  if (!dialogActive) {
    if (keys.has("arrowleft") || keys.has("a")) vx -= 1;
    if (keys.has("arrowright")|| keys.has("d")) vx += 1;
    if (keys.has("arrowup")   || keys.has("w")) vy -= 1;
    if (keys.has("arrowdown") || keys.has("s")) vy += 1;
  }

  player.moving = (vx !== 0 || vy !== 0);
  if (player.moving) {
    const len = Math.hypot(vx, vy) || 1;
    vx /= len; vy /= len;

    if (Math.abs(vx) > Math.abs(vy)) player.dir = (vx < 0) ? 1 : 2;
    else if (Math.abs(vy) > 0) player.dir = (vy < 0) ? 3 : 0;

    const dx = vx * player.speed * dt;
    const dy = vy * player.speed * dt;
    tryMove(dt, dx, dy);
  }

  // animation
  if (player.moving) {
    player.animTime += dt * player.animSpeed;
    player.frame = 1 + (Math.floor(player.animTime) % 4);
  } else { player.animTime = 0; player.frame = 0; }

  // Silvio idle animation
  silvio.animTime += dt * silvio.animSpeed;
  silvio.frame = 0; // keep him idle unless you want him to "breathe" walk frames

  // Door teleport (only in grass map, door exists there)
  if (currentMap === "grass") tryDoorTeleport();

  // Show E prompt if close to Silvio and quest not accepted
  if (currentMap === "grass" && !questAccepted && !dialogActive) {
    const d = distanceCenter(player, silvio);
    if (d < 120) showPrompt("press E to accept quest");
    else hidePrompt();
  } else {
    hidePrompt();
  }
}

function render() {
  // draw map
  ctx.drawImage(mapBuffer, 0, 0);

  // draw door (only on grass)
  if (currentMap === "grass") {
    ctx.save();
    ctx.fillStyle = "#5a3a21";
    ctx.fillRect(door.x, door.y, door.w, door.h);
    ctx.fillStyle = "#a27b52";
    ctx.fillRect(door.x+4, door.y+4, door.w-8, door.h-8);
    // simple knob
    ctx.fillStyle = "#2b2b2b";
    ctx.fillRect(door.x + door.w - 12, door.y + door.h/2 - 2, 4, 4);
    ctx.restore();
  }

  // draw Silvio (only on grass)
  if (currentMap === "grass") {
    const imgS = framesS[silvio.dir][silvio.frame];
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(imgS, 0,0, BASE_W_S, BASE_H_S, Math.round(silvio.x), Math.round(silvio.y), DRAW_W_S, DRAW_H_S);

    // Floating "?" if quest not accepted
    if (!questAccepted) {
      const t = performance.now() * 0.004;
      const bob = Math.sin(t) * 6;
      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("?", Math.round(silvio.x + DRAW_W_S/2), Math.round(silvio.y - 10 + bob));
    }

    // Silvio name
    ctx.fillStyle = "#fff";
    ctx.font = "16px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.fillText("Silvio", Math.round(silvio.x + DRAW_W_S/2), Math.round(silvio.y - 14));
  }

  // draw player
  const img = frames[player.dir][player.frame];
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(img, 0,0, BASE_W, BASE_H, Math.round(player.x), Math.round(player.y), DRAW_W, DRAW_H);

  // Player name
  ctx.fillStyle = "#fff";
  ctx.font = "16px system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.fillText(player.name, Math.round(player.x + DRAW_W/2), Math.round(player.y - 10));
}

function loop(ts) {
  if (!running) return;
  const dt = Math.min(0.033, (ts - last) / 1000 || 0); // clamp dt
  last = ts;
  update(dt);
  render();
  requestAnimationFrame(loop);
}

/* =========================
   Start overlay
   ========================= */
const startOverlay = document.getElementById("startOverlay");
document.getElementById("startBtn").addEventListener("click", () => {
  startOverlay.style.display = "none";
  running = true;
  last = performance.now();
  requestAnimationFrame(loop);
});

/* =========================
   Init
   ========================= */
resize();
buildStaticMap();
positionSilvioAndDoor();
// place player somewhere central
player.x = (W - DRAW_W)/2;
player.y = (H - DRAW_H)/2;
</script>
</body>
</html>
